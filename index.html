<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MeVolt OBS Overlay</title>

  <style>
    :root{
      --bg: rgba(10,12,18,.88);
      --glass: rgba(255,255,255,.08);
      --glass2: rgba(255,255,255,.12);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --good: rgba(90, 255, 170, .95);
      --warn: rgba(255, 210, 120, .95);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --pad: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing: border-box; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: var(--sans);
      color: var(--text);
      overflow: hidden;
      background: transparent;
    }

    /* Mode 0: Jardim Canvas */
    body.mode-0{
      background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 50%, #90EE90 100%);
      overflow: hidden;
    }
    body.mode-0 .bgfill{ display:none; }
    body.mode-0 .frames{ display:none; }
    body.mode-0 .topbar{ display:none; }
    body.mode-0 .layout{ display:none; }
    body.mode-0 .buysHistory{ display:none; }
    body.mode-0 .ticker{ display:none; }
    body.mode-0 .overlayCounters{ display:none; }
    body.mode-0 .overlayStatus{ display:none; }
    
    .gardenCanvas{
      display: none;
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
    }
    body.mode-0 .gardenCanvas{
      display: block;
    }
    
    .gardenStats{
      display: none;
      position: absolute;
      top: 24px;
      left: 24px;
      right: 24px;
      z-index: 100;
    }
    body.mode-0 .gardenStats{
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .gardenStatCard{
      padding: 16px 24px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.3);
      background: rgba(255,255,255,.15);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0,0,0,.2);
      min-width: 180px;
    }
    .gardenStatCard .label{
      font-size: 13px;
      color: rgba(255,255,255,.9);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 8px;
      font-weight: 700;
    }
    .gardenStatCard .value{
      font-size: 32px;
      font-weight: 900;
      color: #fff;
      font-family: var(--mono);
      line-height: 1.2;
      letter-spacing: 0.5px;
    }

    /* Mode 1 & 2: Overlay com caixa bonita nas bordas e green screen no centro */
    body.mode-1, body.mode-2{
      background: #00ff00; /* Green screen para chroma key */
    }
    body.mode-1 .bgfill, body.mode-2 .bgfill{ display:none; }
    body.mode-1 .frames, body.mode-2 .frames{ display:none; }
    
    /* Layout compacto nas bordas para mode-1 e mode-2 */
    body.mode-1 .layout, body.mode-2 .layout{ 
      display: none; 
    }
    body.mode-1 .main, body.mode-2 .main{ 
      display: none; 
    }
    
    /* Topbar compacto para overlays - melhorado mode-1 */
    body.mode-1 .topbar, body.mode-2 .topbar{
      position: absolute;
      left: 24px;
      right: 24px;
      top: 18px;
      max-width: none;
      padding: 8px 16px;
      z-index: 100; /* Logo acima dos mini cards */
      justify-content: space-between;
    }
    /* Brand/Logo acima de tudo */
    body.mode-1 .brand, body.mode-2 .brand{
      position: relative;
      z-index: 101;
    }
    
    /* MODE-1: Estilos específicos - tudo bem maior e melhor estruturado */
    body.mode-1 .topbar{
      padding: 8px 16px;
      left: 32px;
      right: 32px;
      top: 24px;
      min-height: auto;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    }
    
    /* Logo MUITO maior no mode-1 */
    body.mode-1 .brand .logo{
      width: 100px;
      height: 100px;
      border-radius: 18px;
    }
    /* Remover texto MeVolt no mode-1 */
    body.mode-1 .btext{
      display: none;
    }
    
    /* MODE-2: Estilos específicos - tudo bem maior e melhor estruturado */
    body.mode-2 .topbar{
      padding: 24px 32px;
      left: 32px;
      right: 32px;
      top: 24px;
    }
    
    /* Logo MUITO maior no mode-2 */
    body.mode-2 .brand .logo{
      width: 120px;
      height: 120px;
      border-radius: 20px;
    }
    
    /* Remover texto MeVolt no mode-2 também */
    body.mode-2 .btext{
      display: none;
    }
    
    /* Textos muito maiores no mode-2 */
    body.mode-2 .pill{
      font-size: 22px;
      padding: 16px 24px;
      border-radius: 12px;
    }
    body.mode-2 .pill strong{
      font-size: 28px;
    }
    body.mode-2 .price .label{
      font-size: 18px;
    }
    body.mode-2 .price .val{
      font-size: 36px;
      font-weight: 900;
    }
    body.mode-2 .price .unit{
      font-size: 18px;
    }
    
    /* Textos muito maiores no mode-1 */
    body.mode-1 .pill{
      font-size: 20px;
      padding: 14px 22px;
      border-radius: 12px;
    }
    body.mode-1 .pill strong{
      font-size: 26px;
    }
    body.mode-1 .price .label{
      font-size: 16px;
    }
    body.mode-1 .price .val{
      font-size: 32px;
      font-weight: 900;
    }
    body.mode-1 .price .unit{
      font-size: 16px;
    }
    
    /* Mini contadores para overlays */
    .overlayCounters{
      display: none;
      position: absolute;
      left: 24px;
      top: 72px;
      gap: 12px;
      z-index: 10;
    }
    body.mode-1 .overlayCounters, body.mode-2 .overlayCounters{
      display: flex;
    }
    .overlayCounter{
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .overlayCounter .label{
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .overlayCounter .value{
      font-size: 16px;
      font-weight: 900;
      font-family: var(--mono);
    }
    body.mode-1 .overlayCounter .label{
      font-size: 14px;
    }
    body.mode-1 .overlayCounter .value{
      font-size: 22px;
    }
    
    /* Contadores muito maiores no mode-2 */
    body.mode-2 .overlayCounter{
      padding: 14px 22px;
      border-radius: 12px;
      gap: 12px;
    }
    body.mode-2 .overlayCounter .label{
      font-size: 18px;
    }
    body.mode-2 .overlayCounter .value{
      font-size: 32px;
    }
    body.mode-2 .overlayCounters{
      top: 160px;
      left: 32px;
      gap: 16px;
    }
    
    .overlayCounter.buys .value{ color: var(--good); }
    .overlayCounter.sells .value{ color: var(--warn); }
    
    /* Compras history sempre visível em overlays */
    body.mode-1 .buysHistory, body.mode-2 .buysHistory{
      position: absolute;
      right: 24px;
      top: 140px;
      bottom: auto;
      width: 280px;
      max-height: 300px;
    }
    
    /* Compras history maior no mode-1 */
    body.mode-1 .buysHistory{
      right: 32px;
      top: 180px;
      width: 340px;
      max-height: 400px;
      padding: 20px;
      border-radius: 16px;
    }
    body.mode-1 .buysHistory .title{
      font-size: 18px;
      margin-bottom: 14px;
    }
    body.mode-1 .buysHistory .buyItem{
      padding: 11px 15px;
      font-size: 14px;
      margin-bottom: 9px;
    }
    body.mode-1 .buysHistory .buyItem .wallet{
      font-size: 13px;
    }
    body.mode-1 .buysHistory .buyItem .sol{
      font-size: 15px;
    }
    
    /* Compras history maior no mode-2 */
    body.mode-2 .buysHistory{
      right: 32px;
      top: 200px;
      width: 360px;
      max-height: 400px;
      padding: 20px;
      border-radius: 16px;
    }
    body.mode-2 .buysHistory .title{
      font-size: 20px;
      margin-bottom: 16px;
    }
    body.mode-2 .buysHistory .buyItem{
      padding: 12px 16px;
      font-size: 15px;
      margin-bottom: 10px;
    }
    body.mode-2 .buysHistory .buyItem .wallet{
      font-size: 14px;
    }
    body.mode-2 .buysHistory .buyItem .sol{
      font-size: 16px;
    }
    
    /* Ticker sempre visível */
    body.mode-1 .ticker, body.mode-2 .ticker{
      position: absolute;
      left: 24px;
      right: 320px;
      bottom: 18px;
    }
    /* Remover ticker na page id=1 */
    body.mode-1 .ticker{
      display: none !important;
    }
    body.mode-1 .ticker .label{
      font-size: 16px;
    }
    body.mode-1 .ticker .marquee .track{
      font-size: 15px;
    }
    
    /* Ticker maior no mode-2 */
    body.mode-2 .ticker{
      left: 32px;
      right: 400px;
      bottom: 24px;
      padding: 16px 20px;
      border-radius: 12px;
    }
    body.mode-2 .ticker .label{
      font-size: 20px;
      margin-bottom: 10px;
    }
    body.mode-2 .ticker .marquee .track{
      font-size: 18px;
      padding: 8px 0;
    }
    
    /* Comentários da live do Pump.fun (mode-1) */
    .liveComments{
      display: none;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      max-height: 450px;
      overflow-y: auto;
      padding: 20px;
      border-radius: var(--radius);
      border: 3px solid rgba(90,255,170,.4);
      background: rgba(0,0,0,.75);
      backdrop-filter: blur(15px);
      box-shadow: 0 0 30px rgba(90,255,170,.2), var(--shadow);
      z-index: 5;
      pointer-events: none;
    }
    body.mode-1 .liveComments{
      display: block;
      width: 600px;
      max-height: 500px;
      padding: 24px;
      border-radius: 16px;
      border-width: 4px;
    }
    /* Comentários NÃO aparecem no mode-2 - apenas alert aparece quando há compra */
    body.mode-2 .liveComments{
      display: none;
    }
    .liveComments::-webkit-scrollbar{
      width: 6px;
    }
    .liveComments::-webkit-scrollbar-track{
      background: rgba(255,255,255,.05);
      border-radius: 3px;
    }
    .liveComments::-webkit-scrollbar-thumb{
      background: rgba(90,255,170,.3);
      border-radius: 3px;
    }
    .commentItem{
      padding: 10px 12px;
      margin-bottom: 8px;
      border-radius: 10px;
      background: rgba(255,255,255,.08);
      border-left: 3px solid rgba(90,255,170,.5);
      animation: slideInComment 0.3s ease-out;
    }
    @keyframes slideInComment{
      from{
        opacity: 0;
        transform: translateX(-20px);
      }
      to{
        opacity: 1;
        transform: translateX(0);
      }
    }
    .commentItem .commentUser{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(90,255,170,.9);
      font-weight: 700;
      margin-bottom: 4px;
    }
    body.mode-1 .commentItem .commentUser{
      font-size: 14px;
    }
    .commentItem .commentText{
      font-size: 13px;
      color: var(--text);
      line-height: 1.4;
    }
    body.mode-1 .commentItem .commentText{
      font-size: 15px;
    }
    .commentItem .commentTime{
      font-size: 10px;
      color: var(--muted);
      margin-top: 4px;
    }
    
    /* Alert ajustado - visível em todas as páginas */
    body.mode-0 .alert{
      bottom: 80px;
      left: 24px;
    }
    
    /* Alert centralizado e bem maior no mode-1 - só aparece quando há compra */
    body.mode-1 .alert{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      bottom: auto;
      width: 580px;
      max-width: 90vw;
      padding: 28px;
      border-radius: 20px;
      border-width: 4px;
      z-index: 100;
    }
    body.mode-1 .alert .mascot{
      width: 100px;
      height: 100px;
    }
    body.mode-1 .alert .mascot img{
      width: 100px;
      height: 100px;
    }
    body.mode-1 .alert .content{
      gap: 10px;
    }
    body.mode-1 .alert .content .title{
      font-size: 28px;
      margin-bottom: 6px;
    }
    body.mode-1 .alert .content .wallet{
      font-size: 20px;
    }
    body.mode-1 .alert .content .amount{
      font-size: 32px;
      font-weight: 900;
    }
    
    /* Alert centralizado e bem maior no mode-2 - só aparece quando há compra */
    body.mode-2 .alert{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      bottom: auto;
      width: 600px;
      max-width: 90vw;
      padding: 32px;
      border-radius: 20px;
      border-width: 4px;
      z-index: 100;
    }
    body.mode-2 .alert .mascot{
      width: 120px;
      height: 120px;
    }
    body.mode-2 .alert .mascot img{
      width: 120px;
      height: 120px;
    }
    body.mode-2 .alert .content{
      gap: 12px;
    }
    body.mode-2 .alert .content .title{
      font-size: 32px;
      margin-bottom: 8px;
    }
    body.mode-2 .alert .content .wallet{
      font-size: 24px;
    }
    body.mode-2 .alert .content .amount{
      font-size: 36px;
      font-weight: 900;
    }
    
    /* Status WS para overlays */
    .overlayStatus{
      display: none;
      position: absolute;
      left: 24px;
      top: 130px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.3);
      backdrop-filter: blur(10px);
      font-size: 11px;
      color: var(--muted);
      align-items: center;
      gap: 6px;
      z-index: 10;
    }
    body.mode-1 .overlayStatus, body.mode-2 .overlayStatus{
      display: flex;
    }
    
    /* Status maior no mode-1 */
    body.mode-1 .overlayStatus{
      left: 32px;
      top: 260px;
      padding: 10px 18px;
      font-size: 14px;
      gap: 8px;
    }
    body.mode-1 .overlayStatus .dot{
      width: 12px;
      height: 12px;
    }
    body.mode-2 .overlayStatus{
      left: 32px;
      top: 280px;
      padding: 10px 18px;
      font-size: 14px;
      gap: 8px;
    }
    body.mode-2 .overlayStatus .dot{
      width: 12px;
      height: 12px;
    }
    .overlayStatus .dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,210,120,.9);
    }
    .overlayStatus .dot.live{
      background: rgba(90,255,170,.95);
    }

    .stage{
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Background (only in page0) */
    .bgfill{
      position:absolute; inset:0;
      background:
        radial-gradient(1200px 700px at 20% 20%, rgba(140,120,255,.18), transparent 55%),
        radial-gradient(900px 600px at 80% 30%, rgba(60,220,255,.14), transparent 55%),
        radial-gradient(1100px 700px at 50% 100%, rgba(255,120,180,.10), transparent 55%),
        linear-gradient(180deg, rgba(6,8,14,.92), rgba(6,8,14,.82));
      filter: saturate(1.1);
    }

    .topbar{
      position:absolute; left:24px; right:24px; top:18px;
      display:flex; align-items:center; justify-content: space-between;
      gap:14px;
      padding: 12px 14px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    /* Topbar mais fino no mode-1 */
    body.mode-1 .topbar{
      gap: 12px;
      align-items: center;
    }
    /* Remover barra visual do spacer no mode-1 */
    body.mode-1 .spacer{
      display: none;
    }

    .brand{
      display:flex; align-items:center; gap:12px; min-width: 260px;
      position: relative;
      z-index: 1001;
    }
    .logo{
      width:42px; height:42px; border-radius: 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid var(--stroke);
      display:grid; place-items:center;
      overflow:hidden;
    }
    .logo img{ width:100%; height:100%; object-fit:contain; }
    .btext .name{ font-weight:800; letter-spacing:.2px; font-size: 18px; line-height: 1.1; }
    .btext .sub{ font-size: 12px; color: var(--muted); }

    .pill{
      display:flex; align-items:center; gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
    }
    .pill strong{ color: var(--text); font-weight: 700; }

    .spacer{ flex:1; }
    /* Remover barra visual do spacer no mode-1 */
    body.mode-1 .spacer{
      display: none;
    }

    .price{
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(90,255,170,.25);
      background: rgba(90,255,170,.10);
    }
    .priceRow{
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .priceSub{
      font-size: 12px;
      color: var(--muted);
      font-family: var(--mono);
      line-height: 1;
      white-space: nowrap;
    }
    .price .label{ font-size: 12px; color: rgba(90,255,170,.88); font-weight: 700; letter-spacing:.2px; }
    .price .val{ font-size: 18px; font-weight: 900; color: var(--text); font-family: var(--mono); }
    .price .unit{ font-size: 12px; color: var(--muted); font-family: var(--mono); }

    .layout{
      position:absolute; left:24px; right:24px; top:92px; bottom:74px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 18px;
      z-index: 5;
    }

    .card{
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    .left{
      padding: 16px;
      display:flex; flex-direction:column; gap:12px;
    }
    .mascot{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.2);
      overflow:hidden;
      height: 360px;
      display:grid; place-items:center;
    }
    .mascot img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      transform: translateY(6px);
      filter: drop-shadow(0 18px 30px rgba(0,0,0,.35));
      transition: transform 0.3s ease-out;
    }
    
    /* Animação de salto para o mascot */
    @keyframes jumpMascot {
      0% { transform: translateY(6px) scale(1); }
      50% { transform: translateY(-40px) scale(1.1); }
      100% { transform: translateY(6px) scale(1); }
    }
    
    .mascot img.jump {
      animation: jumpMascot 0.6s ease-out;
    }

    .meta{
      display:grid; gap:10px;
    }
    .kv{
      display:flex; gap:10px; align-items:center;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.16);
    }
    .kv .k{
      color: var(--muted);
      font-size: 12px;
      width: 92px;
    }
    .kv .v{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex:1;
    }

    .main{
      position:relative;
      padding: 0;
      overflow:hidden;
    }
    .mainHead{
      display:flex; align-items:center; justify-content:space-between;
      padding: 14px 16px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0,0,0,.18);
    }
    .mainHead .title{
      font-weight: 900;
      letter-spacing:.2px;
    }
    .counters{
      display:flex; gap:16px;
      align-items:center;
    }
    .counter{
      display:flex; flex-direction:column; align-items:center;
      padding: 8px 16px;
      border-radius: 12px;
      background: rgba(0,0,0,.2);
    }
    .counter .label{
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing:1px;
    }
    .counter .value{
      font-size: 24px;
      font-weight: 900;
      font-family: var(--mono);
      margin-top: 4px;
    }
    .counter.buys .value{ color: var(--good); }
    .counter.sells .value{ color: var(--warn); }
    
    .status{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(255,210,120,.9);
      box-shadow: 0 0 0 6px rgba(255,210,120,.12);
    }
    .dot.live{
      background: rgba(90,255,170,.95);
      box-shadow: 0 0 0 6px rgba(90,255,170,.12);
    }

    .playerWrap{
      position:absolute; inset: 52px 0 0 0;
      padding: 16px;
      display:grid;
      grid-template-rows: 1fr;
    }
    body.mode-2 .priceSub{
      font-size: 18px;
    }
    body.mode-1 .priceSub{
      font-size: 16px;
    }
    .player{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.24);
      overflow:hidden;
      display:grid; place-items:center;
      color: var(--muted);
      font-size: 13px;
    }
    .player iframe{
      width:100%; height:100%;
      border:0;
    }

    /* Last 5 Buys Panel */
    .buysHistory{
      position:absolute;
      right:24px;
      bottom:92px;
      width:320px;
      max-height:400px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding: 14px;
      z-index: 10;
    }
    .buysHistory h3{
      font-size: 13px;
      font-weight: 900;
      margin:0 0 12px 0;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing:1px;
    }
    .buyList{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .buyItem{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--stroke);
    }
    .buyItem .wallet{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }
    .buyItem .amount{
      font-family: var(--mono);
      font-size: 13px;
      font-weight: 700;
      color: var(--good);
    }

    /* Footer tasks ticker */
    .ticker{
      position:absolute; left:24px; right:24px; bottom:18px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius: 999px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding: 10px 14px;
      display:flex; gap:12px; align-items:center;
      overflow:hidden;
      z-index: 10;
    }
    .ticker .label{
      font-weight: 900;
      color: var(--text);
      white-space: nowrap;
      cursor: text;
    }
    .ticker .label:focus{
      outline: 2px solid var(--good);
      outline-offset: 2px;
      border-radius: 4px;
    }
    .marquee{
      flex:1;
      overflow:hidden;
      position:relative;
    }
    .marquee .track{
      display:inline-block;
      white-space: nowrap;
      will-change: transform;
      color: var(--muted);
      font-size: 13px;
      cursor: text;
    }
    .marquee .track:focus{
      outline: 2px solid var(--good);
      outline-offset: 2px;
      border-radius: 4px;
      animation: none !important;
    }
    .marquee .track.animate{
      animation: scroll 22s linear infinite;
    }
    @keyframes scroll{
      from{ transform: translateX(0); }
      to{ transform: translateX(-50%); }
    }

    /* Alert donation */
    .alert{
      position:absolute;
      left: 24px;
      bottom: 92px;
      width: 520px;
      pointer-events:none;
      display:flex;
      gap:12px;
      align-items:center;
      padding: 14px 18px;
      border-radius: 18px;
      border: 1px solid rgba(90,255,170,.30);
      background: rgba(0,0,0,.75);
      backdrop-filter: blur(10px);
      box-shadow: 0 0 40px rgba(90,255,170,.3), var(--shadow);
      transform: translateX(-120%);
      opacity: 0;
      z-index: 100;
    }
    .alert.show{
      animation: slideInOut 6.5s ease-in-out forwards;
    }
    .alert .mascot{
      width: 64px;
      height: 64px;
      border-radius: 12px;
      overflow:hidden;
      flex-shrink:0;
      border: 1px solid rgba(90,255,170,.3);
    }
    .alert .mascot img{
      width:100%;
      height:100%;
      object-fit:contain;
    }
    .alert .content{
      flex:1;
    }
    .alert .content .title{
      font-size: 14px;
      color: rgba(90,255,170,.9);
      font-weight: 700;
      margin-bottom: 4px;
    }
    .alert .content .wallet{
      font-family: var(--mono);
      font-size: 13px;
      color: var(--text);
      margin-bottom: 2px;
    }
    .alert .content .amount{
      font-family: var(--mono);
      font-size: 16px;
      font-weight: 900;
      color: var(--good);
    }
    @keyframes slideInOut{
      0%   { transform: translateX(-120%); opacity: 0; }
      12%  { transform: translateX(0); opacity: 1; }
      88%  { transform: translateX(0); opacity: 1; }
      100% { transform: translateX(-120%); opacity: 0; }
    }
    /* Animação centralizada para mode-2 */
    @keyframes slideInOutCenter{
      0%   { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      10%  { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      90%  { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    }
    body.mode-2 .alert.show{
      animation: slideInOutCenter 6.5s ease-in-out forwards;
    }
    @keyframes bounce{
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .alert.show .mascot{
      animation: bounce 0.6s ease-in-out 3;
    }
  </style>
</head>
<body>
  <div class="stage">
    <div class="bgfill"></div>
    <div class="frames">
      <div class="frame-screen"></div>
      <div class="frame-cam"></div>
    </div>

    <div class="topbar">
      <div class="brand">
        <div class="logo">
          <img src="https://mewvolt.online/logo.png" alt="MeVolt" />
        </div>
        <div class="btext">
          <div class="name">MeVolt</div>
          <div class="sub">Memecoin Development</div>
        </div>
      </div>

      <div class="pill">
        <span>Viewers:</span>
        <strong id="viewers">—</strong>
      </div>

      <div class="price">
        <span class="label">1 MEWVOLT</span>
        <div class="priceRow">
          <span class="val" id="priceVal">—</span>
          <span class="unit">SOL</span>
        </div>
        <div class="priceSub" id="priceUsd">$—</div>
      </div>

      <div class="pill">
        <span>Market Cap:</span>
        <strong id="marketCap">—</strong>
      </div>

      <div class="pill">
        <span>Holders:</span>
        <strong id="holders">—</strong>
      </div>
    </div>

    <!-- Mini contadores para overlays (mode 1 e 2) -->
    <div class="overlayCounters">
      <div class="overlayCounter buys">
        <span class="label">Buys</span>
        <span class="value" id="overlayBuyCount">0</span>
      </div>
      <div class="overlayCounter sells">
        <span class="label">Sells</span>
        <span class="value" id="overlaySellCount">0</span>
      </div>
    </div>

    <!-- Status WS para overlays -->
    <div class="overlayStatus">
      <div class="dot" id="overlayWsStatus"></div>
      <span id="overlayWsStatusText">Connecting...</span>
    </div>

    <div class="layout">
      <div class="card left">
        <div class="mascot">
          <img src="https://mewvolt.online/character.png" alt="MeVolt Mascot" />
        </div>
        <div class="meta">
          <div class="kv">
            <span class="k">Contract:</span>
            <span class="v" id="contract">CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump</span>
          </div>
          <div class="kv">
            <span class="k">Platform:</span>
            <span class="v">Pump.fun</span>
          </div>
        </div>
      </div>

      <div class="card main">
        <div class="mainHead">
          <div class="title">Live Activity</div>
          <div class="counters">
            <div class="counter buys">
              <div class="label">Buys</div>
              <div class="value" id="buyCount">0</div>
            </div>
            <div class="counter sells">
              <div class="label">Sells</div>
              <div class="value" id="sellCount">0</div>
            </div>
          </div>
          <div class="status">
            <div class="dot" id="wsStatus"></div>
            <span id="wsStatusText">Connecting...</span>
          </div>
        </div>
        <div class="playerWrap">
          <div class="player">
            <!-- Optional iframe player can be embedded here -->
          </div>
        </div>
      </div>
    </div>

    <div class="buysHistory">
      <h3>Last 5 Buys</h3>
      <div class="buyList" id="buyList"></div>
    </div>

    <div class="ticker">
      <span class="label" id="tickerTitle" contenteditable="true">Working on:</span>
      <div class="marquee">
        <div class="track" id="tickerTrack" contenteditable="true"></div>
      </div>
    </div>

    <!-- Comentários da live (mode-1) -->
    <div class="liveComments" id="liveComments">
      <div id="commentsList"></div>
    </div>

    <div class="alert" id="alert">
      <div class="mascot">
        <img src="https://mewvolt.online/character.png" alt="" />
      </div>
      <div class="content">
        <div class="title">New Buy!</div>
        <div class="wallet" id="alertWallet"></div>
        <div class="amount" id="alertAmount"></div>
      </div>
    </div>

    <!-- Canvas para jardim animado (Mode 0) -->
    <canvas class="gardenCanvas" id="gardenCanvas"></canvas>

    <!-- Stats no jardim -->
    <div class="gardenStats">
      <div class="gardenStatCard">
        <div class="label">Viewers</div>
        <div class="value" id="gardenViewers">—</div>
      </div>
      <div class="gardenStatCard">
        <div class="label">Price</div>
        <div class="value" id="gardenPrice">— SOL</div>
      </div>
      <div class="gardenStatCard">
        <div class="label">Market Cap</div>
        <div class="value" id="gardenMarketCap">—</div>
      </div>
      <div class="gardenStatCard">
        <div class="label">Holders</div>
        <div class="value" id="gardenHolders">—</div>
      </div>
    </div>
  </div>

  <audio id="alertSound" preload="auto">
    <source src="alert.mp3" type="audio/mpeg" />
  </audio>

  <!-- Socket.IO para conexão com chat do Pump Fun -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

  <script>
    const CONFIG = {
      contract: 'CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump',
      pumpUrl: 'https://pump.fun/coin/CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump',
      wsUrl: 'wss://pumpportal.fun/api/data',
      chatWsUrl: 'https://livechat.pump.fun', // WebSocket do chat do Pump Fun
      // CORS proxies (ordem = tentativa). Sem servidor local: depende de proxies públicos.
      // Nota: proxies públicos podem ficar instáveis/indisponíveis; por isso tentamos vários.
      corsProxies: [
        'https://corsproxy.io/?',
        'https://api.allorigins.win/raw?url=',
        'https://api.allorigins.win/get?url=',
        'https://r.jina.ai/',
        'https://api.codetabs.com/v1/proxy?quest='
      ],
      solscanApi: 'https://api.solscan.io', // API Solscan
      enableSolscanPolling: false, // Desligado por padrão: evita erros de CORS em modo "só frontend"
      minBuyThreshold: 0.01, // SOL
      alertCooldown: 1500 // ms
    };

    // Mode detection - Page 0 (Jardim), Page 1 ou Page 2
    const urlParams = new URLSearchParams(window.location.search);
    const pageId = urlParams.get('id');
    if (pageId === '0' || !pageId) {
      document.body.classList.add('mode-0');
    } else if (pageId === '1') {
      document.body.classList.add('mode-1');
    } else if (pageId === '2') {
      document.body.classList.add('mode-2');
    }

    // State
    let buyCount = 0;
    let sellCount = 0;
    let lastBuys = [];
    let lastAlertTime = 0;
    let ws = null;
    let chatSocket = null; // WebSocket para chat do Pump Fun
    let priceInterval = null;
    let viewersInterval = null;
    let tasksInterval = null;
    let solscanInterval = null;
    let processedTxSignatures = new Set(); // Rastrear transações já processadas

    // DOM Elements
    const viewersEl = document.getElementById('viewers');
    const priceValEl = document.getElementById('priceVal');
    const priceUsdEl = document.getElementById('priceUsd');
    const marketCapEl = document.getElementById('marketCap');
    const holdersEl = document.getElementById('holders');
    const buyCountEl = document.getElementById('buyCount');
    const sellCountEl = document.getElementById('sellCount');
    const buyListEl = document.getElementById('buyList');
    const alertEl = document.getElementById('alert');
    const alertWalletEl = document.getElementById('alertWallet');
    const alertAmountEl = document.getElementById('alertAmount');
    const alertSoundEl = document.getElementById('alertSound');
    const wsStatusEl = document.getElementById('wsStatus');
    const wsStatusTextEl = document.getElementById('wsStatusText');
    const overlayWsStatusEl = document.getElementById('overlayWsStatus');
    const overlayWsStatusTextEl = document.getElementById('overlayWsStatusText');
    const overlayBuyCountEl = document.getElementById('overlayBuyCount');
    const overlaySellCountEl = document.getElementById('overlaySellCount');
    const tickerTitleEl = document.getElementById('tickerTitle');
    const tickerTrackEl = document.getElementById('tickerTrack');
    
    // Tornar ticker editável - remover animação quando focado
    if (tickerTitleEl) {
      tickerTitleEl.addEventListener('focus', () => {
        tickerTitleEl.style.outline = '2px solid var(--good)';
        tickerTitleEl.style.outlineOffset = '2px';
        tickerTitleEl.style.borderRadius = '4px';
      });
      tickerTitleEl.addEventListener('blur', () => {
        tickerTitleEl.style.outline = 'none';
      });
    }
    
    if (tickerTrackEl) {
      tickerTrackEl.addEventListener('focus', () => {
        tickerTrackEl.classList.remove('animate'); // Parar animação
        tickerTrackEl.style.outline = '2px solid var(--good)';
        tickerTrackEl.style.outlineOffset = '2px';
        tickerTrackEl.style.borderRadius = '4px';
      });
      tickerTrackEl.addEventListener('blur', () => {
        tickerTrackEl.style.outline = 'none';
        // Retomar animação se houver conteúdo
        if (tickerTrackEl.textContent.trim()) {
          tickerTrackEl.textContent = tickerTrackEl.textContent.trim() + ' • ';
          const text = tickerTrackEl.textContent;
          tickerTrackEl.textContent = text + text; // Duplicate for seamless loop
          tickerTrackEl.classList.add('animate');
        }
      });
    }

    // Helper: Shorten wallet address
    function shortenAddress(addr) {
      if (!addr) return '—';
      return `${addr.slice(0, 4)}…${addr.slice(-4)}`;
    }

    // Helper: Format SOL
    function formatSOL(amount) {
      if (!amount) return '—';
      return parseFloat(amount).toFixed(4) + ' SOL';
    }

    function formatUSDCompact(value) {
      const num = typeof value === 'number' ? value : parseFloat(String(value).replace(/[^0-9.]/g, ''));
      if (!Number.isFinite(num)) return null;
      if (num >= 1_000_000_000) return (num / 1_000_000_000).toFixed(2) + 'B';
      if (num >= 1_000_000) return (num / 1_000_000).toFixed(2) + 'M';
      if (num >= 1_000) return (num / 1_000).toFixed(2) + 'K';
      return num.toFixed(0);
    }

    function formatUsdPrice(value) {
      const num = typeof value === 'number' ? value : parseFloat(String(value));
      if (!Number.isFinite(num)) return '$—';
      if (num >= 1) return '$' + num.toFixed(4);
      if (num >= 0.01) return '$' + num.toFixed(6);
      if (num >= 0.0001) return '$' + num.toFixed(8);
      return '$' + num.toPrecision(4);
    }

    function formatSolPrice(value) {
      const num = typeof value === 'number' ? value : parseFloat(String(value));
      if (!Number.isFinite(num)) return '—';
      if (num >= 0.01) return num.toFixed(6);
      if (num >= 0.0001) return num.toFixed(8);
      return num.toPrecision(4);
    }

    function findFirstNumberByKeys(obj, keys) {
      const wanted = new Set(keys.map(k => String(k).toLowerCase()));
      const seen = new Set();
      const stack = [obj];
      while (stack.length) {
        const cur = stack.pop();
        if (!cur || typeof cur !== 'object') continue;
        if (seen.has(cur)) continue;
        seen.add(cur);
        if (Array.isArray(cur)) {
          for (const v of cur) stack.push(v);
          continue;
        }
        for (const [k, v] of Object.entries(cur)) {
          const key = k.toLowerCase();
          if (wanted.has(key)) {
            const n = typeof v === 'number' ? v : parseFloat(String(v).replace(/[^0-9.]/g, ''));
            if (Number.isFinite(n)) return n;
          }
          if (v && typeof v === 'object') stack.push(v);
        }
      }
      return null;
    }

    function getCorsProxyCandidates() {
      // Back-compat: se alguém tiver CONFIG.corsProxy antigo, ainda funciona
      const list = Array.isArray(CONFIG.corsProxies) ? CONFIG.corsProxies.slice() : [];
      if (typeof CONFIG.corsProxy === 'string' && CONFIG.corsProxy) list.push(CONFIG.corsProxy);
      // Remover duplicatas/vazios
      return [...new Set(list.filter(Boolean))];
    }

    function shouldSkipDirectFetch(targetUrl) {
      // Evita spam no console quando sabemos que vai falhar por CORS.
      // (ex: Pump.fun bloqueia CORS; Solscan/Helius frequentemente bloqueiam)
      try {
        const u = new URL(targetUrl);
        const host = u.hostname.toLowerCase();
        return (
          host === 'pump.fun' ||
          host.endsWith('.pump.fun') ||
          host === 'public-api.solscan.io' ||
          host === 'api.solscan.io' ||
          host === 'api.helius.xyz'
        );
      } catch {
        return false;
      }
    }

    function unwrapMaybeJsonProxy(text) {
      const trimmed = (text || '').trim();
      if (!trimmed) return text;
      if (!(trimmed.startsWith('{') || trimmed.startsWith('['))) return text;
      try {
        const obj = JSON.parse(trimmed);
        // allorigins /get?url= => { contents: "..." }
        if (obj && typeof obj === 'object') {
          if (typeof obj.contents === 'string') return obj.contents;
          if (obj.data && typeof obj.data.contents === 'string') return obj.data.contents;
        }
      } catch {
        // ignore
      }
      return text;
    }

    async function fetchTextWithCorsFallback(targetUrl) {
      // 1) Tentar direto (se o servidor permitir CORS)
      if (!shouldSkipDirectFetch(targetUrl)) {
        try {
          const direct = await fetch(targetUrl);
          if (direct.ok) return await direct.text();
        } catch (_) {
          // CORS bloqueado ou erro de rede
        }
      }

      const proxies = getCorsProxyCandidates();
      let lastErr = null;
      for (const proxy of proxies) {
        try {
          const proxiedUrl = proxy.startsWith('https://r.jina.ai/')
            ? (proxy + targetUrl) // r.jina.ai espera a URL completa no path
            : (proxy + encodeURIComponent(targetUrl));
          const res = await fetch(proxiedUrl);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const raw = await res.text();
          return unwrapMaybeJsonProxy(raw);
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('All CORS proxy attempts failed');
    }

    async function fetchJsonWithCorsFallback(targetUrl) {
      const text = await fetchTextWithCorsFallback(targetUrl);
      try {
        return JSON.parse(text);
      } catch {
        // Algumas proxies podem envolver a resposta. Tentar achar o primeiro JSON válido.
        const start = text.indexOf('{');
        const startArr = text.indexOf('[');
        const idx = startArr !== -1 && (start === -1 || startArr < start) ? startArr : start;
        if (idx !== -1) {
          return JSON.parse(text.slice(idx));
        }
        throw new Error('Failed to parse JSON from response');
      }
    }

    // Fetch Pump.fun viewers (via CORS proxy)
    // NOTA: Pump Fun NÃO tem API pública oficial para viewers.
    // Esta função usa scraping HTML como solução alternativa.
    // Opções disponíveis:
    // 1. Scraping HTML (atual) - funciona mas é frágil
    // 2. WebSocket do chat pode ter informações de viewers (não confirmado)
    // 3. PumpPortal.fun não oferece endpoint de viewers
    async function fetchViewers() {
      try {
        const html = await fetchTextWithCorsFallback(CONFIG.pumpUrl);
        
        // Tentar múltiplos padrões para encontrar viewer count
        let viewers = null;
        
        // Pattern 1: JSON-like "viewers": <num>
        const jsonMatch = html.match(/"viewers"\s*:\s*(\d+)/i);
        if (jsonMatch) {
          viewers = parseInt(jsonMatch[1], 10);
        }
        
        // Pattern 2: "X viewers" or "X watching"
        if (!viewers) {
          const textMatch = html.match(/(\d+)\s+(viewers?|watching)/i);
          if (textMatch) {
            viewers = parseInt(textMatch[1], 10);
          }
        }
        
        // Pattern 3: HTML tags com números seguidos de viewers
        if (!viewers) {
          const htmlMatch = html.match(/<[^>]*>(\d+)<[^>]*>\s*(?:viewers?|watching|live)/i);
          if (htmlMatch) {
            viewers = parseInt(htmlMatch[1], 10);
          }
        }
        
        if (viewers !== null) {
          viewersEl.textContent = viewers;
        } else {
          viewersEl.textContent = '—';
        }
      } catch (err) {
        console.error('Viewers fetch error:', err);
        viewersEl.textContent = '—';
      }
    }

    // Fetch all coin data (unified function that runs every 10 seconds)
    // coinData será inicializado aqui
    if (typeof coinData === 'undefined') {
      var coinData = { 
        viewers: null, 
        marketCap: null, 
        holders: null,
        price: null,
        volume24h: null,
        liquidity: null
      };
    }
    
    if (typeof pumpData === 'undefined') {
      var pumpData = {};
    }
    
    // Comentários da live
    let liveComments = [];
    let commentsInterval = null;
    
    async function fetchAllCoinData() {
      // Fetch Pump.fun data and price in parallel
      try {
        await Promise.allSettled([
          fetchPumpData(),
          fetchPrice(),
          fetchHoldersCount(),
          fetchLiveComments()
        ]);
        
        // Garantir que os dados do DexScreener sejam aplicados mesmo se Pump.fun falhar
        // O fetchPrice já atualiza market cap, então isso já está coberto
        console.log('[All Coin Data] Atualização completa:', {
          viewers: coinData?.viewers ?? null,
          marketCap: coinData?.marketCap ?? null,
          holders: coinData?.holders ?? null,
          price: coinData?.price ?? null
        });
      } catch (err) {
        console.error('[All Coin Data] Erro geral:', err);
      }
    }
    
    // Fetch transações do contrato via Solscan para detectar compras
    async function fetchSolscanTransactions() {
      // Se estiver em file://, pular
      if (window.location.protocol === 'file:') {
        return;
      }
      
      try {
        // Usar API pública do Solscan via proxy CORS
        // Endpoint para buscar transações recentes de um token/contrato
        const solscanUrl = `https://public-api.solscan.io/account/transactions?account=${CONFIG.contract}&limit=10`;
        const transactions = await fetchJsonWithCorsFallback(solscanUrl);
        
        if (Array.isArray(transactions) && transactions.length > 0) {
          processSolscanTransactions(transactions);
        }
        
      } catch (err) {
        // Tentar método alternativo via Helius ou outro endpoint
        try {
          // Alternativa: usar endpoint de token transactions
          const altUrl = `https://api.helius.xyz/v0/addresses/${CONFIG.contract}/transactions?api-key=public&limit=10`;
          const altData = await fetchJsonWithCorsFallback(altUrl);
          if (Array.isArray(altData)) processSolscanTransactions(altData);
        } catch (altErr) {
          // Silenciar erros de fallback
        }
      }
    }
    
    // Processar transações do Solscan e detectar compras
    function processSolscanTransactions(transactions) {
      if (!transactions || !Array.isArray(transactions)) return;
      
      const now = Math.floor(Date.now() / 1000);
      
      transactions.forEach(tx => {
        // Verificar se já processamos esta transação
        const txSig = tx.signature || tx.slot || tx.hash || JSON.stringify(tx);
        if (processedTxSignatures.has(txSig)) {
          return;
        }
        
        // Verificar timestamp (só processar transações recentes)
        const txTime = tx.blockTime || tx.timestamp || (tx.blockTimeSeconds || 0);
        if (txTime > 0) {
          const timeDiff = now - txTime;
          // Só processar transações dos últimos 3 minutos
          if (timeDiff > 180) return;
        }
        
        // Procurar por transfers de SOL (compras)
        let solAmount = 0;
        let fromAddress = null;
        
        // Método 1: Verificar preBalances/postBalances
        if (tx.preBalances && tx.postBalances && tx.accountKeys) {
          for (let i = 0; i < tx.accountKeys.length && i < tx.preBalances.length; i++) {
            const account = tx.accountKeys[i];
            const preBal = parseFloat(tx.preBalances[i] || 0) / 1e9;
            const postBal = parseFloat(tx.postBalances[i] || 0) / 1e9;
            const diff = preBal - postBal;
            
            // Se alguém enviou SOL (diferença positiva) e não é o próprio contrato
            if (diff > CONFIG.minBuyThreshold && diff < 100 && account !== CONFIG.contract) {
              solAmount = diff;
              fromAddress = account;
              break;
            }
          }
        }
        
        // Método 2: Verificar em nativeTransfers
        if (!fromAddress && tx.nativeTransfers) {
          for (const transfer of tx.nativeTransfers) {
            if (transfer.to === CONFIG.contract && transfer.from !== CONFIG.contract) {
              const amount = parseFloat(transfer.amount || 0) / 1e9;
              if (amount >= CONFIG.minBuyThreshold) {
                solAmount = amount;
                fromAddress = transfer.from;
                break;
              }
            }
          }
        }
        
        // Método 3: Verificar em instructions
        if (!fromAddress && tx.instructions) {
          for (const instruction of tx.instructions) {
            if (instruction.programId === CONFIG.contract || 
                (instruction.accounts && instruction.accounts.includes(CONFIG.contract))) {
              // Tentar extrair informações de transfer
              if (instruction.data) {
                // Procurar por valores de SOL nos dados
                const dataStr = JSON.stringify(instruction);
                const amountMatch = dataStr.match(/"amount":\s*(\d+)/i);
                if (amountMatch) {
                  const amount = parseFloat(amountMatch[1]) / 1e9;
                  if (amount >= CONFIG.minBuyThreshold && instruction.accounts) {
                    solAmount = amount;
                    fromAddress = instruction.accounts[0] || instruction.from;
                    break;
                  }
                }
              }
            }
          }
        }
        
        // Se encontrou uma compra válida
        if (solAmount >= CONFIG.minBuyThreshold && fromAddress) {
          processedTxSignatures.add(txSig);
          
          // Evitar duplicatas muito recentes (mesmo wallet e valor similar)
          const isDuplicate = lastBuys.some(buy => 
            buy.wallet === fromAddress && 
            Math.abs(buy.sol - solAmount) < 0.001 &&
            Date.now() - (buy.timestamp || 0) < 5000
          );
          
          if (!isDuplicate) {
            // Atualizar contadores
            buyCount++;
            if (buyCountEl) buyCountEl.textContent = buyCount;
            if (overlayBuyCountEl) overlayBuyCountEl.textContent = buyCount;
            
            // Adicionar timestamp
            const buyEntry = { wallet: fromAddress, sol: solAmount, tokens: null, timestamp: Date.now() };
            lastBuys.unshift(buyEntry);
            if (lastBuys.length > 5) lastBuys.pop();
            updateBuyList();
            
            // Mostrar alerta
            showBuyAlert(fromAddress, solAmount);
          }
        }
      });
    }
    
    let pumpDataAttempts = 0;
    async function fetchPumpData() {
      try {
        // Em file:// pode falhar por CORS, mas tentamos mesmo (best-effort)
        if (window.location.protocol === 'file:') {
          pumpDataAttempts++;
          if (pumpDataAttempts === 1) {
            console.warn('[Pump Data] CORS: recomenda-se usar servidor HTTP local (ex: python -m http.server 8000)');
          }
        }
        
        const html = await fetchTextWithCorsFallback(CONFIG.pumpUrl);
        
        let viewers = null;
        let marketCap = null;
        let holders = null;

        // Se existir __NEXT_DATA__, tentar extrair valores direto (bem mais confiável)
        try {
          const nextDataMatch = html.match(/<script[^>]*id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
          if (nextDataMatch && nextDataMatch[1]) {
            const nextJson = JSON.parse(nextDataMatch[1]);
            const stack = [nextJson];
            const seen = new Set();

            const pickNumber = (obj, keys) => {
              while (stack.length) {
                const cur = stack.pop();
                if (!cur || typeof cur !== 'object') continue;
                if (seen.has(cur)) continue;
                seen.add(cur);
                for (const k of keys) {
                  if (Object.prototype.hasOwnProperty.call(cur, k)) {
                    const v = cur[k];
                    const n = typeof v === 'number' ? v : parseFloat(String(v).replace(/[^0-9.]/g, ''));
                    if (Number.isFinite(n) && n > 0) return n;
                  }
                }
                if (Array.isArray(cur)) {
                  for (const item of cur) stack.push(item);
                } else {
                  for (const key of Object.keys(cur)) stack.push(cur[key]);
                }
              }
              return null;
            };

            // Procurar chaves comuns
            viewers = viewers ?? pickNumber(nextJson, ['viewers', 'viewerCount', 'liveViewers']);
            holders = holders ?? pickNumber(nextJson, ['holders', 'holderCount', 'uniqueHolders']);
            const mcapNum = pickNumber(nextJson, ['marketCap', 'mcap', 'market_cap']);
            if (mcapNum) marketCap = String(formatUSDCompact(mcapNum) || mcapNum);
          }
        } catch (_) {
          // ignorar
        }
        
        // Viewers patterns - melhorados para encontrar viewers da stream
        // Pump.fun pode usar diferentes estruturas, vamos tentar múltiplos padrões
        const viewersPatterns = [
          // JSON embutido
          /"viewers?"\s*:\s*(\d+)/i,
          /"viewerCount"\s*:\s*(\d+)/i,
          /"liveViewers"\s*:\s*(\d+)/i,
          /"watching"\s*:\s*(\d+)/i,
          // Texto visível na página
          /(\d+)\s+(viewers?|watching|watching now)/i,
          /<[^>]*>(\d+)<[^>]*>\s*(?:viewers?|watching|live|online)/i,
          /viewers?[:\s]*(\d+)/i,
          /watching[:\s]*(\d+)/i,
          /(\d+)\s+people\s+(watching|viewing)/i,
          // Em elementos específicos do Pump.fun
          /<div[^>]*class="[^"]*viewer[^"]*"[^>]*>[\s\S]*?(\d+)[\s\S]*?<\/div>/i,
          /<span[^>]*data-viewers="(\d+)"/i,
          // Em scripts embutidos
          /window\.__INITIAL_STATE__[\s\S]*?"viewers?"\s*:\s*(\d+)/i,
          /__NEXT_DATA__[\s\S]*?"viewers?"\s*:\s*(\d+)/i
        ];
        for (const pattern of viewersPatterns) {
          const match = html.match(pattern);
          if (match && match[1]) {
            const parsed = parseInt(match[1].replace(/,/g, ''), 10);
            if (parsed > 0 && parsed < 1000000) { // Validação razoável
              viewers = parsed;
              console.log('[Pump Data] Viewers encontrados:', viewers, 'via pattern');
              break;
            }
          }
        }
        
        // Market Cap patterns - melhorados
        const marketCapPatterns = [
          // JSON embutido
          /"market.*?cap["\s:]+[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /"mcap["\s:]+[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /"marketCap["\s:]+[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          // Texto visível
          /market.*?cap[:\s]*[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /mcap[:\s]*[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          // Em scripts
          /window\.__INITIAL_STATE__[\s\S]*?"marketCap"\s*:\s*"?(\d+[.,]?\d*[KMkm]?)/i,
          /__NEXT_DATA__[\s\S]*?"marketCap"\s*:\s*"?(\d+[.,]?\d*[KMkm]?)/i
        ];
        for (const pattern of marketCapPatterns) {
          const match = html.match(pattern);
          if (match && match[1]) {
            marketCap = match[1].replace(/['"]/g, '').trim();
            console.log('[Pump Data] Market Cap encontrado:', marketCap);
            break;
          }
        }
        
        // Holders pattern - mais padrões
        const holdersPatterns = [
          // JSON embutido
          /"holders?"\s*:\s*(\d+)/i,
          /"holderCount"\s*:\s*(\d+)/i,
          /"uniqueHolders"\s*:\s*(\d+)/i,
          // Texto visível
          /(\d+)\s+holders?/i,
          /holders?[:\s]*(\d+)/i,
          /holder.*?count[:\s]*(\d+)/i,
          /unique.*?holders?[:\s]*(\d+)/i,
          // Em scripts
          /window\.__INITIAL_STATE__[\s\S]*?"holders?"\s*:\s*(\d+)/i,
          /__NEXT_DATA__[\s\S]*?"holders?"\s*:\s*(\d+)/i
        ];
        for (const pattern of holdersPatterns) {
          const match = html.match(pattern);
          if (match && match[1]) {
            const parsed = parseInt(match[1].replace(/,/g, ''), 10);
            if (parsed > 0 && parsed < 10000000) { // Validação
              holders = parsed;
              console.log('[Pump Data] Holders encontrados:', holders);
              break;
            }
          }
        }
        
        // Volume 24h patterns
        let volume24h = null;
        const volumePatterns = [
          /"volume.*?24h["\s:]+[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /volume.*?24h[:\s]*[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /24h.*?volume[:\s]*[\$]?(\d+[.,]?\d*[KMkm]?)/i
        ];
        for (const pattern of volumePatterns) {
          const match = html.match(pattern);
          if (match) {
            volume24h = match[1];
            break;
          }
        }
        
        // Liquidity patterns
        let liquidity = null;
        const liquidityPatterns = [
          /"liquidity["\s:]+[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /liquidity[:\s]*[\$]?(\d+[.,]?\d*[KMkm]?)/i,
          /liq[:\s]*[\$]?(\d+[.,]?\d*[KMkm]?)/i
        ];
        for (const pattern of liquidityPatterns) {
          const match = html.match(pattern);
          if (match) {
            liquidity = match[1];
            break;
          }
        }
        
        // Merge data instead of replacing (preserve price from fetchPrice)
        coinData = { 
          ...coinData, // Preserve existing data (like price)
          ...(viewers !== null && { viewers }),
          ...(marketCap !== null && { marketCap }),
          ...(holders !== null && { holders }),
          ...(volume24h !== null && { volume24h }),
          ...(liquidity !== null && { liquidity })
        };
        pumpData = { viewers, marketCap, holders, volume24h, liquidity };
        
        // Log para debug detalhado
        console.log('[Coin Data Update - Pump.fun]', {
          viewers,
          marketCap,
          holders,
          volume24h,
          liquidity,
          timestamp: new Date().toLocaleTimeString(),
          htmlLength: html.length,
          foundInHtml: { 
            viewers: viewers !== null, 
            marketCap: marketCap !== null, 
            holders: holders !== null 
          }
        });
        
        // Se não encontrou dados, DexScreener será usado como fallback em fetchPrice()
        if (holders === null || marketCap === null) {
          console.log('[Pump Data] Alguns dados não encontrados via scraping, DexScreener será usado como fallback...');
        }
        
        // Update viewers
        if (viewers !== null) {
          if (viewersEl) viewersEl.textContent = viewers;
          const gardenViewersEl = document.getElementById('gardenViewers');
          if (gardenViewersEl) gardenViewersEl.textContent = viewers;
        } else {
          if (viewersEl) viewersEl.textContent = '—';
          const gardenViewersEl = document.getElementById('gardenViewers');
          if (gardenViewersEl) gardenViewersEl.textContent = '—';
        }

        // Update Market Cap (topbar + garden)
        if (marketCapEl) {
          if (marketCap) {
            marketCapEl.textContent = marketCap.includes('$') ? marketCap : '$' + marketCap;
          } else {
            marketCapEl.textContent = '—';
          }
        }
        
        // Update garden stats
        const gardenMarketCapEl = document.getElementById('gardenMarketCap');
        if (gardenMarketCapEl) {
          if (marketCap) {
            gardenMarketCapEl.textContent = marketCap.includes('$') ? marketCap : '$' + marketCap;
          } else {
            gardenMarketCapEl.textContent = '—';
          }
        }
        const gardenHoldersEl = document.getElementById('gardenHolders');
        if (gardenHoldersEl) gardenHoldersEl.textContent = holders ? holders.toLocaleString() : '—';

        // Update Holders (topbar)
        if (holdersEl) holdersEl.textContent = holders ? holders.toLocaleString() : '—';
        
      } catch (err) {
        pumpDataAttempts++;
        // Só logar erro na primeira tentativa ou se for erro HTTP (não CORS)
        if (pumpDataAttempts === 1 || (err.message && err.message.includes('HTTP'))) {
          if (window.location.protocol === 'file:') {
            // Já foi logado acima, não repetir
          } else {
            console.error('Pump data fetch error:', err);
          }
        }
        if (viewersEl) viewersEl.textContent = '—';
        const gardenViewersEl = document.getElementById('gardenViewers');
        if (gardenViewersEl) gardenViewersEl.textContent = '—';

        if (marketCapEl) marketCapEl.textContent = '—';
        if (holdersEl) holdersEl.textContent = '—';
      }
    }

    // Fetch token price and additional data from DexScreener
    let priceAttempts = 0;
    async function fetchPrice() {
      try {
        const apiUrl = `https://api.dexscreener.com/token-pairs/v1/solana/${CONFIG.contract}`;
        let data;
        try {
          const res = await fetch(apiUrl);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          data = await res.json();
        } catch (_) {
          // Fallback via proxies públicos (se o browser bloquear cross-origin)
          data = await fetchJsonWithCorsFallback(apiUrl);
        }
        priceAttempts = 0; // Reset on success
        
        if (data && data.pairs && data.pairs.length > 0) {
          // Encontrar pair com maior liquidez
          let bestPair = data.pairs[0];
          let maxLiquidity = parseFloat(bestPair.liquidity?.usd || 0);
          
          for (const pair of data.pairs) {
            const liq = parseFloat(pair.liquidity?.usd || 0);
            if (liq > maxLiquidity) {
              maxLiquidity = liq;
              bestPair = pair;
            }
          }
          
          const priceNative = bestPair.priceNative ? parseFloat(bestPair.priceNative) : NaN;
          const priceUsd = bestPair.priceUsd ? parseFloat(bestPair.priceUsd) : NaN;

          // Update price (SOL) + USD
          if (Number.isFinite(priceNative)) {
            const priceText = formatSolPrice(priceNative);
            coinData.price = priceText;
            if (priceValEl) priceValEl.textContent = priceText;
          } else {
            if (priceValEl) priceValEl.textContent = '—';
          }

          if (priceUsdEl) {
            priceUsdEl.textContent = formatUsdPrice(priceUsd);
          }

          const gardenPriceEl = document.getElementById('gardenPrice');
          if (gardenPriceEl) {
            const solPart = Number.isFinite(priceNative) ? (formatSolPrice(priceNative) + ' SOL') : '— SOL';
            const usdPart = formatUsdPrice(priceUsd);
            gardenPriceEl.textContent = solPart + ' (' + usdPart + ')';
          }
          
          // Update market cap from DexScreener if available
          const rawMcap = (bestPair.marketCap ?? bestPair.fdv);
          const mcapNum = rawMcap ? parseFloat(rawMcap) : NaN;
          if (Number.isFinite(mcapNum)) {
            const mcapFormatted = '$' + formatUSDCompact(mcapNum);
            const gardenMarketCapEl = document.getElementById('gardenMarketCap');
            if (gardenMarketCapEl) gardenMarketCapEl.textContent = mcapFormatted;
            if (marketCapEl) marketCapEl.textContent = mcapFormatted;
            coinData.marketCap = mcapFormatted;
          }
          
          // DexScreener não fornece holders diretamente, mas vamos tentar buscar de outra fonte se necessário
          
          // Update volume 24h if not found in Pump.fun scraping
          if (bestPair.volume?.h24 && !coinData.volume24h) {
            const vol = parseFloat(bestPair.volume.h24);
            let volFormatted;
            if (vol >= 1000000) {
              volFormatted = (vol / 1000000).toFixed(2) + 'M';
            } else if (vol >= 1000) {
              volFormatted = (vol / 1000).toFixed(2) + 'K';
            } else {
              volFormatted = vol.toFixed(0);
            }
            coinData.volume24h = '$' + volFormatted;
          }
          
          // Update liquidity if not found in Pump.fun scraping
          if (bestPair.liquidity?.usd && !coinData.liquidity) {
            const liq = parseFloat(bestPair.liquidity.usd);
            let liqFormatted;
            if (liq >= 1000000) {
              liqFormatted = (liq / 1000000).toFixed(2) + 'M';
            } else if (liq >= 1000) {
              liqFormatted = (liq / 1000).toFixed(2) + 'K';
            } else {
              liqFormatted = liq.toFixed(0);
            }
            coinData.liquidity = '$' + liqFormatted;
          }
        } else {
          if (priceValEl) priceValEl.textContent = '—';
          if (priceUsdEl) priceUsdEl.textContent = '$—';
          const gardenPriceEl = document.getElementById('gardenPrice');
          if (gardenPriceEl) gardenPriceEl.textContent = '—';
        }
      } catch (err) {
        priceAttempts++;
        // Só logar erro na primeira tentativa ou se for erro HTTP (não CORS)
        if (priceAttempts === 1 || (err.message && err.message.includes('HTTP'))) {
          console.error('Price fetch error:', err);
        }
        if (priceValEl) priceValEl.textContent = '—';
        if (priceUsdEl) priceUsdEl.textContent = '$—';
        const gardenPriceEl = document.getElementById('gardenPrice');
        if (gardenPriceEl) gardenPriceEl.textContent = '—';
      }
    }

    // Fetch holders count (Solscan via proxy). Cached to avoid hitting every 10s.
    let holdersLastFetchAt = 0;
    async function fetchHoldersCount() {
      try {
        const now = Date.now();
        if (now - holdersLastFetchAt < 60_000) return; // 1 min cache
        holdersLastFetchAt = now;

        // Se estiver em file://, pular (fetch cross-origin tende a falhar)
        if (window.location.protocol === 'file:') return;

        const mint = CONFIG.contract;
        const candidates = [
          `https://public-api.solscan.io/token/meta?tokenAddress=${mint}`,
          `https://public-api.solscan.io/token/holders?tokenAddress=${mint}&offset=0&limit=1`,
          `https://api.solscan.io/token/meta?tokenAddress=${mint}`,
          `https://api.solscan.io/token/holders?tokenAddress=${mint}&offset=0&limit=1`,
          `https://api.solscan.io/token/holders?token=${mint}&offset=0&limit=1`
        ];

        let holdersCount = null;
        for (const url of candidates) {
          try {
            const json = await fetchJsonWithCorsFallback(url);
            // tentar chaves comuns
            holdersCount =
              findFirstNumberByKeys(json, ['holders', 'holder', 'holderCount', 'holdersCount', 'total', 'totalHolders', 'count']) ||
              null;
            if (Number.isFinite(holdersCount) && holdersCount > 0) break;
          } catch {
            // try next
          }
        }

        if (Number.isFinite(holdersCount) && holdersCount > 0) {
          coinData.holders = holdersCount;
          if (holdersEl) holdersEl.textContent = holdersCount.toLocaleString();
          const gardenHoldersEl = document.getElementById('gardenHolders');
          if (gardenHoldersEl) gardenHoldersEl.textContent = holdersCount.toLocaleString();
        }
      } catch (err) {
        // silencioso: holders depende muito de CORS/proxy
      }
    }
    
    // Fetch comentários da live do Pump.fun
    let commentsAttempts = 0;
    async function fetchLiveComments() {
      // Buscar comentários no mode-1 e mode-2
      if (pageId !== '1' && pageId !== '2') return;
      
      // Se estiver em file://, pular
      if (window.location.protocol === 'file:') {
        commentsAttempts++;
        if (commentsAttempts === 1) {
          console.warn('[Comments] CORS: Comentários requerem servidor HTTP');
        }
        return;
      }
      
      try {
        const html = await fetchTextWithCorsFallback(CONFIG.pumpUrl);
        
        const newComments = [];
        
        // Extrair chat da Pump.fun - estrutura específica com data-message-id
        // Procurar por todas as mensagens com data-message-id
        const messagePattern = /<div\s+data-message-id="([^"]+)"[^>]*>([\s\S]*?)<\/div>\s*(?=<div\s+data-message-id|<\/div>\s*<\/div>\s*<\/div>|$)/gi;
        
        let messageMatch;
        const processedMessageIds = new Set();
        
        while ((messageMatch = messagePattern.exec(html)) !== null && newComments.length < 20) {
          const messageId = messageMatch[1];
          const messageHtml = messageMatch[2];
          
          // Evitar processar a mesma mensagem várias vezes
          if (processedMessageIds.has(messageId)) continue;
          processedMessageIds.add(messageId);
          
          // Extrair nome do utilizador (dentro de <a> com href para profile)
          const userMatch = messageHtml.match(/<a[^>]*href="https:\/\/pump\.fun\/profile\/([^"]+)"[^>]*>([^<]+)<\/a>/i);
          const userName = userMatch ? (userMatch[2] || userMatch[1] || 'User') : null;
          
          if (!userName) continue; // Pular se não encontrar nome de utilizador
          
          // Extrair texto da mensagem (dentro de <p class="break-words">)
          const textMatches = [
            messageHtml.match(/<p\s+class="break-words"[^>]*>([\s\S]*?)<\/p>/i),
            messageHtml.match(/<p[^>]*class="[^"]*break-words[^"]*"[^>]*>([\s\S]*?)<\/p>/i)
          ];
          
          let messageText = null;
          for (const match of textMatches) {
            if (match && match[1]) {
              messageText = match[1];
              break;
            }
          }
          
          if (!messageText) continue;
          
          // Limpar HTML do texto (remover tags mas manter links se houver)
          // Primeiro, processar links @username
          messageText = messageText.replace(/<a[^>]*href="https:\/\/pump\.fun\/profile\/([^"]+)"[^>]*class="[^"]*font-semibold[^"]*"[^>]*>([^<]+)<\/a>/gi, '@$2');
          // Remover todas as outras tags HTML
          messageText = messageText.replace(/<[^>]+>/g, '');
          // Decodificar entidades HTML comuns
          messageText = messageText.replace(/&nbsp;/g, ' ').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
          // Limpar espaços extras
          messageText = messageText.replace(/\s+/g, ' ').trim();
          
          // Filtrar mensagens vazias ou muito curtas
          if (!messageText || messageText.length < 2) continue;
          
          // Extrair timestamp (formato HH:MM dentro de span)
          const timeMatch = messageHtml.match(/<span[^>]*class="[^"]*text-\[10px\][^"]*"[^>]*>(\d{1,2}:\d{2})<\/span>/i);
          let timestamp = Date.now();
          if (timeMatch) {
            const timeStr = timeMatch[1];
            const [hours, minutes] = timeStr.split(':').map(Number);
            const now = new Date();
            // Assumir que é hoje, ajustar se necessário
            timestamp = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes).getTime();
            // Se o tempo é maior que agora, assumir que foi ontem
            if (timestamp > now.getTime()) {
              timestamp -= 24 * 60 * 60 * 1000;
            }
          }
          
          // Verificar se é duplicado
          const isDuplicate = liveComments.some(c => {
            const sameText = c.text.toLowerCase().trim() === messageText.toLowerCase().trim();
            const sameUser = c.user.toLowerCase().trim() === userName.toLowerCase().trim();
            const recent = Date.now() - c.timestamp < 300000; // 5 minutos
            return sameText && sameUser && recent;
          });
          
          if (!isDuplicate && messageText.length >= 2 && messageText.length <= 500) {
            // Processar comandos do chat
            processChatCommand(messageText);
            
            // Encurtar nome de utilizador se necessário
            const displayName = userName.length > 20 ? userName.slice(0, 20) : userName;
            
            newComments.push({
              user: displayName,
              text: messageText.length > 200 ? messageText.slice(0, 200) + '...' : messageText,
              timestamp: timestamp,
              messageId: messageId
            });
          }
        }
        
        // Fallback: se não encontrou mensagens com data-message-id, tentar padrões alternativos
        if (newComments.length === 0) {
          // Buscar por divs com classes de mensagem de chat
          const chatMessagePattern = /<div[^>]*class="[^"]*mb-2[^"]*flex[^"]*w-full[^"]*items-start[^"]*"[^>]*>([\s\S]*?)<\/div>\s*(?=<div[^>]*class="[^"]*mb-2|<\/div>\s*<\/div>)/gi;
          let chatMatch;
          let chatCount = 0;
          
          while ((chatMatch = chatMessagePattern.exec(html)) !== null && chatCount < 15) {
            const chatHtml = chatMatch[1];
            
            // Extrair nome e texto
            const userMatch = chatHtml.match(/<a[^>]*href="[^"]*profile\/([^"]+)"[^>]*>([^<]+)<\/a>/i);
            const textMatch = chatHtml.match(/<p[^>]*class="[^"]*break-words[^"]*"[^>]*>([\s\S]*?)<\/p>/i);
            
            if (userMatch && textMatch) {
              const userName = userMatch[2] || userMatch[1];
              let text = textMatch[1].replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();
              
              if (text && text.length >= 2 && text.length <= 500) {
                const isDuplicate = liveComments.some(c => 
                  c.text.toLowerCase().trim() === text.toLowerCase().trim()
                );
                
                if (!isDuplicate) {
                  // Processar comandos do chat
                  processChatCommand(text);
                  
                  newComments.push({
                    user: userName.length > 20 ? userName.slice(0, 20) : userName,
                    text: text.length > 200 ? text.slice(0, 200) + '...' : text,
                    timestamp: Date.now() - chatCount * 10000
                  });
                  chatCount++;
                }
              }
            }
          }
        }
        
        // Adicionar novos comentários (mais recentes primeiro)
        if (newComments.length > 0) {
          // Ordenar por timestamp (mais recentes primeiro)
          newComments.sort((a, b) => b.timestamp - a.timestamp);
          
          // Combinar com comentários existentes, removendo duplicatas
          const existingTexts = new Set(liveComments.map(c => c.text.toLowerCase().trim()));
          const uniqueNewComments = newComments.filter(c => 
            !existingTexts.has(c.text.toLowerCase().trim())
          );
          
          if (uniqueNewComments.length > 0) {
            liveComments = [...uniqueNewComments, ...liveComments].slice(0, 30); // Manter últimos 30
            updateCommentsDisplay();
          }
        }
        
        commentsAttempts = 0;
      } catch (err) {
        commentsAttempts++;
        if (commentsAttempts === 1 || (commentsAttempts % 10 === 0)) {
          console.log('[Comments] Fetch error:', err.message);
        }
      }
    }
    
    // Atualizar display de comentários
    function updateCommentsDisplay() {
      const commentsListEl = document.getElementById('commentsList');
      // Mostrar comentários no mode-1 e mode-2
      if (!commentsListEl || (pageId !== '1' && pageId !== '2')) return;
      
      commentsListEl.innerHTML = '';
      
      // Ordenar comentários por timestamp (mais recentes primeiro)
      const sortedComments = [...liveComments].sort((a, b) => b.timestamp - a.timestamp);
      
      // Mostrar últimos 8 comentários
      sortedComments.slice(0, 8).forEach(comment => {
        const div = document.createElement('div');
        div.className = 'commentItem';
        const timeAgo = Math.floor((Date.now() - comment.timestamp) / 1000);
        let timeText;
        if (timeAgo < 60) {
          timeText = `${timeAgo}s`;
        } else if (timeAgo < 3600) {
          timeText = `${Math.floor(timeAgo / 60)}m`;
        } else {
          timeText = `${Math.floor(timeAgo / 3600)}h`;
        }
        
        div.innerHTML = `
          <div class="commentUser">${escapeHtml(comment.user)}</div>
          <div class="commentText">${escapeHtml(comment.text)}</div>
          <div class="commentTime">${timeText} ago</div>
        `;
        commentsListEl.appendChild(div);
      });
    }
    
    // Função auxiliar para escapar HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Load tasks ticker
    let tasksLoadAttempts = 0;
    async function loadTasks() {
      // Se estiver em file://, pular tentativa (CORS não permite)
      if (window.location.protocol === 'file:') {
        tasksLoadAttempts++;
        if (tasksLoadAttempts === 1) {
          console.warn('[Tasks] CORS: Tasks.json requer servidor HTTP. Use: python -m http.server 8000');
          // Usar valores padrão se não conseguir carregar
          if (!tickerTitleEl.textContent || tickerTitleEl.textContent.trim() === '') {
            tickerTitleEl.textContent = 'Working on:';
          }
        }
        return; // Não tentar fazer fetch em file://
      }
      
      try {
        const tasksPath = `MeVoltOBS/tasks.json?t=${Date.now()}`;
        const res = await fetch(tasksPath);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        const data = await res.json();
        if (data.title) tickerTitleEl.textContent = data.title;
        if (data.items && data.items.length > 0) {
          const text = data.items.join(' • ') + ' • ';
          tickerTrackEl.textContent = text + text; // Duplicate for seamless loop
          tickerTrackEl.classList.add('animate');
        }
        tasksLoadAttempts = 0; // Reset on success
      } catch (err) {
        tasksLoadAttempts++;
        // Só logar erro na primeira tentativa ou se for erro HTTP (não CORS)
        if (tasksLoadAttempts === 1 || (err.message && err.message.includes('HTTP'))) {
          console.error('Tasks fetch error:', err);
        }
        // Se falhar, manter conteúdo anterior (não limpar)
      }
    }

    // Update last buys list
    function updateBuyList() {
      buyListEl.innerHTML = '';
      lastBuys.slice(0, 5).forEach(buy => {
        const div = document.createElement('div');
        div.className = 'buyItem';
        div.innerHTML = `
          <span class="wallet">${shortenAddress(buy.wallet)}</span>
          <span class="amount">${formatSOL(buy.sol)}</span>
        `;
        buyListEl.appendChild(div);
      });
    }

    // Show buy alert
    function showBuyAlert(wallet, solAmount) {
      const now = Date.now();
      if (now - lastAlertTime < CONFIG.alertCooldown) return;
      if (parseFloat(solAmount) < CONFIG.minBuyThreshold) return;

      lastAlertTime = now;
      alertWalletEl.textContent = shortenAddress(wallet);
      alertAmountEl.textContent = formatSOL(solAmount);

      alertEl.classList.remove('show');
      void alertEl.offsetWidth; // Trigger reflow
      alertEl.classList.add('show');

      // Play sound (alert notification)
      try {
        alertSoundEl.currentTime = 0;
        alertSoundEl.play().catch(err => {
          console.log('[Buy Alert] Audio play blocked - user interaction may be required:', err);
        });
        console.log('[Buy Alert]', { wallet, solAmount, timestamp: new Date().toLocaleTimeString() });
      } catch (err) {
        console.log('[Buy Alert] Audio error:', err);
      }
    }

    // Connect to PumpPortal WebSocket
    function connectWS() {
      try {
        ws = new WebSocket(CONFIG.wsUrl);

        ws.onopen = () => {
          console.log('WebSocket connected');
          wsStatusEl.classList.add('live');
          wsStatusTextEl.textContent = 'Live';
          if (overlayWsStatusEl) overlayWsStatusEl.classList.add('live');
          if (overlayWsStatusTextEl) overlayWsStatusTextEl.textContent = 'Live';
          // Subscribe to token trades
          ws.send(JSON.stringify({
            method: 'subscribeTokenTrade',
            keys: [CONFIG.contract]
          }));
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'trade' || data.txType) {
              const txType = data.txType || data.type;
              const wallet = data.traderPublicKey || data.wallet || data.user;
              const sol = data.solAmount || data.sol || data.amount;
              const tokens = data.tokenAmount || data.tokens;

              if (txType === 'buy' || txType === 'Buy') {
                buyCount++;
                buyCountEl.textContent = buyCount;
                if (overlayBuyCountEl) overlayBuyCountEl.textContent = buyCount;

                if (wallet && sol) {
                  lastBuys.unshift({ wallet, sol, tokens });
                  if (lastBuys.length > 5) lastBuys.pop();
                  updateBuyList();
                  showBuyAlert(wallet, sol);
                }
              } else if (txType === 'sell' || txType === 'Sell') {
                sellCount++;
                sellCountEl.textContent = sellCount;
                if (overlaySellCountEl) overlaySellCountEl.textContent = sellCount;
              }
            }
          } catch (err) {
            console.error('WS message parse error:', err);
          }
        };

        ws.onerror = (err) => {
          console.error('WebSocket error:', err);
          wsStatusEl.classList.remove('live');
          wsStatusTextEl.textContent = 'Error';
        };

        ws.onclose = () => {
          console.log('WebSocket closed, reconnecting...');
          wsStatusEl.classList.remove('live');
          wsStatusTextEl.textContent = 'Reconnecting...';
          if (overlayWsStatusEl) overlayWsStatusEl.classList.remove('live');
          if (overlayWsStatusTextEl) overlayWsStatusTextEl.textContent = 'Reconnecting...';
          setTimeout(connectWS, 3000);
        };
      } catch (err) {
        console.error('WebSocket connection error:', err);
        wsStatusEl.classList.remove('live');
        wsStatusTextEl.textContent = 'Connection failed';
        if (overlayWsStatusEl) overlayWsStatusEl.classList.remove('live');
        if (overlayWsStatusTextEl) overlayWsStatusTextEl.textContent = 'Connection failed';
      }
    }

    // Função auxiliar para processar mensagem do chat
    function processChatMessage(data) {
      try {
        // Normalizar estrutura de dados (pode vir em diferentes formatos)
        let user = null;
        let text = null;
        let timestamp = Date.now();
        let messageId = null;

        // Tentar diferentes estruturas de dados
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch {
            text = data;
          }
        }

        if (data && typeof data === 'object') {
          // Estrutura padrão
          user = data.user || data.username || data.author || data.sender || 'User';
          text = data.text || data.message || data.content || data.body || '';
          timestamp = data.timestamp || data.time || data.createdAt || Date.now();
          messageId = data.id || data.messageId || data._id || Date.now().toString();
          
          // Se não encontrou user/text, tentar estrutura aninhada
          if (!user && data.data) {
            user = data.data.user || data.data.username || 'User';
            text = data.data.text || data.data.message || '';
          }
        }

        if (!text || text.trim().length === 0) {
          console.log('[Chat WS] Mensagem vazia ignorada:', data);
          return;
        }

        const newComment = {
          user: user || 'User',
          text: text.trim(),
          timestamp: timestamp,
          id: messageId || Date.now().toString()
        };

        console.log('[Chat WS] Nova mensagem recebida:', { user: newComment.user, text: newComment.text.substring(0, 50) });

        // Processar comandos do chat (SEMPRE, mesmo que não exiba o chat)
        processChatCommand(newComment.text);

        // Adicionar comentário se não for duplicado (apenas se estiver em mode-1 ou mode-2)
        if (pageId === '1' || pageId === '2') {
          const isDuplicate = liveComments.some(c => {
            const sameText = c.text.toLowerCase().trim() === newComment.text.toLowerCase().trim();
            const sameUser = c.user.toLowerCase().trim() === newComment.user.toLowerCase().trim();
            const recent = Date.now() - c.timestamp < 300000; // 5 minutos
            return sameText && sameUser && recent;
          });

          if (!isDuplicate) {
            liveComments.unshift(newComment);
            liveComments = liveComments.slice(0, 30); // Manter últimos 30
            updateCommentsDisplay();
          }
        }
      } catch (err) {
        console.error('[Chat WS] Erro ao processar mensagem:', err, data);
      }
    }

    // Connect to Pump Fun Chat WebSocket (Socket.IO)
    function connectChatWS() {
      // Conectar em TODOS os modos para processar comandos
      // (mesmo que o chat não seja exibido visualmente)
      
      try {
        // Verificar se socket.io está disponível
        if (typeof io === 'undefined') {
          console.warn('[Chat WS] Socket.IO não carregado. Tentando carregar...');
          // Tentar carregar socket.io dinamicamente
          const script = document.createElement('script');
          script.src = 'https://cdn.socket.io/4.5.4/socket.io.min.js';
          script.onload = () => {
            console.log('[Chat WS] Socket.IO carregado, conectando...');
            connectChatWS();
          };
          script.onerror = () => {
            console.error('[Chat WS] Falha ao carregar Socket.IO');
          };
          document.head.appendChild(script);
          return;
        }

        // Se já existe conexão, não reconectar
        if (chatSocket && chatSocket.connected) {
          console.log('[Chat WS] Já conectado');
          return;
        }

        // Extrair o token/room ID do contract
        // O Pump Fun usa o contract address como room identifier
        const roomId = CONFIG.contract;
        
        console.log('[Chat WS] Conectando ao chat do Pump Fun...', roomId);
        
        // Conectar ao socket.io do Pump Fun
        chatSocket = io(CONFIG.chatWsUrl, {
          transports: ['websocket', 'polling'], // Tentar ambos
          upgrade: true,
          reconnection: true,
          reconnectionDelay: 2000,
          reconnectionDelayMax: 10000,
          reconnectionAttempts: Infinity, // Tentar reconectar indefinidamente
          timeout: 20000
        });

        chatSocket.on('connect', () => {
          console.log('[Chat WS] ✅ Conectado ao chat do Pump Fun');
          
          // Entrar na sala do token - tentar múltiplos formatos
          chatSocket.emit('join_room', roomId);
          chatSocket.emit('join', roomId);
          chatSocket.emit('subscribe', { room: roomId });
          chatSocket.emit('subscribe', roomId);
          chatSocket.emit('room', roomId);
          
          console.log('[Chat WS] Tentando entrar na sala:', roomId);
        });

        // Evento principal de mensagem
        chatSocket.on('message', (data) => {
          console.log('[Chat WS] Evento "message" recebido:', data);
          processChatMessage(data);
        });

        // Todos os outros eventos possíveis do Pump Fun
        const possibleEvents = [
          'new_message',
          'chat_message',
          'room_message',
          'token_message',
          'chat',
          'msg',
          'comment',
          'live_message',
          'stream_message'
        ];

        possibleEvents.forEach(eventName => {
          chatSocket.on(eventName, (data) => {
            console.log(`[Chat WS] Evento "${eventName}" recebido:`, data);
            processChatMessage(data);
          });
        });

        // Capturar TODOS os eventos para debug
        const originalEmit = chatSocket.emit.bind(chatSocket);
        chatSocket.emit = function(...args) {
          console.log('[Chat WS] Emit:', args[0], args.slice(1));
          return originalEmit(...args);
        };

        // Listener genérico para capturar qualquer evento não tratado
        chatSocket.onAny((eventName, ...args) => {
          if (!['connect', 'disconnect', 'connect_error', 'error'].includes(eventName)) {
            console.log(`[Chat WS] Evento genérico "${eventName}":`, args);
            // Se parecer uma mensagem, tentar processar
            if (args.length > 0 && (args[0]?.text || args[0]?.message || typeof args[0] === 'string')) {
              processChatMessage(args[0]);
            }
          }
        });

        // Tentar obter viewers do chat (se disponível)
        chatSocket.on('viewers', (data) => {
          if (data && typeof data.count === 'number') {
            if (viewersEl) viewersEl.textContent = data.count;
            const gardenViewersEl = document.getElementById('gardenViewers');
            if (gardenViewersEl) gardenViewersEl.textContent = data.count;
          }
        });

        chatSocket.on('room_info', (data) => {
          if (data && data.viewers) {
            if (viewersEl) viewersEl.textContent = data.viewers;
            const gardenViewersEl = document.getElementById('gardenViewers');
            if (gardenViewersEl) gardenViewersEl.textContent = data.viewers;
          }
        });

        chatSocket.on('disconnect', (reason) => {
          console.log('[Chat WS] Desconectado do chat. Razão:', reason);
          // Tentar reconectar após delay
          if (reason === 'io server disconnect') {
            // Servidor desconectou, tentar reconectar manualmente
            setTimeout(() => {
              if (!chatSocket.connected) {
                console.log('[Chat WS] Tentando reconectar...');
                chatSocket.connect();
              }
            }, 2000);
          }
        });

        chatSocket.on('connect_error', (err) => {
          console.warn('[Chat WS] Erro de conexão:', err.message);
          // Fallback para scraping HTML se WebSocket falhar
          console.log('[Chat WS] Usando fallback de scraping HTML para comandos');
        });

        chatSocket.on('error', (err) => {
          console.error('[Chat WS] Erro no socket:', err);
        });

      } catch (err) {
        console.error('[Chat WS] Erro ao conectar:', err);
        // Continuar usando scraping HTML como fallback
      }
    }

    // Processar comandos do chat
    function processChatCommand(text) {
      if (!text || typeof text !== 'string') return;
      
      const trimmed = text.trim();
      const command = trimmed.toLowerCase();
      
      // Comando /jump - fazer o personagem saltar
      if (command === '/jump' || command.startsWith('/jump ')) {
        console.log('[Chat Command] ✅ /jump detectado!');
        
        // Mode-0: Jardim (canvas) - fazer personagem saltar
        if ((pageId === '0' || !pageId) && typeof isJumping !== 'undefined') {
          isJumping = true;
          characterVy = -12 - Math.random() * 4; // Entre -12 e -16
          console.log('[Chat Command] Personagem no jardim saltou!');
        }
        
        // Mode-1 e Mode-2: Mascot (imagem) - animação CSS
        if (pageId === '1' || pageId === '2') {
          const mascotImgs = document.querySelectorAll('.mascot img');
          mascotImgs.forEach(img => {
            // Remover classe anterior se existir
            img.classList.remove('jump');
            // Forçar reflow
            void img.offsetWidth;
            // Adicionar classe de salto
            img.classList.add('jump');
            console.log('[Chat Command] Mascot saltou!');
            
            // Remover classe após animação
            setTimeout(() => {
              img.classList.remove('jump');
            }, 600);
          });
        }
      }
      
      // Comando /redobrar ou /double - fazer personagem redobrar (pular duas vezes)
      if (command === '/redobrar' || command === '/double' || command.startsWith('/redobrar ') || command.startsWith('/double ')) {
        console.log('[Chat Command] ✅ /redobrar detectado!');
        
        // Mode-0: Jardim
        if ((pageId === '0' || !pageId) && typeof isJumping !== 'undefined') {
          // Primeiro salto
          isJumping = true;
          characterVy = -12 - Math.random() * 4;
          
          // Segundo salto após um delay
          setTimeout(() => {
            isJumping = true;
            characterVy = -12 - Math.random() * 4;
          }, 400);
          console.log('[Chat Command] Personagem no jardim redobrou!');
        }
        
        // Mode-1 e Mode-2: Mascot
        if (pageId === '1' || pageId === '2') {
          const mascotImgs = document.querySelectorAll('.mascot img');
          mascotImgs.forEach(img => {
            // Primeiro salto
            img.classList.remove('jump');
            void img.offsetWidth;
            img.classList.add('jump');
            
            // Segundo salto após delay
            setTimeout(() => {
              img.classList.remove('jump');
              void img.offsetWidth;
              img.classList.add('jump');
              setTimeout(() => {
                img.classList.remove('jump');
              }, 600);
            }, 400);
            console.log('[Chat Command] Mascot redobrou!');
          });
        }
      }
      
      // Adicionar mais comandos aqui se necessário
      // Exemplo: /dance, /wave, etc.
    }

    // Canvas Garden Animation (Mode 0)
    let canvas, ctx, characterImg, logoImg;
    let characterX = 100;
    let characterY = 0;
    let characterVx = 0.8; // Mais devagar
    let characterVy = 0;
    let isJumping = false;
    let groundLevel = 0;
    let characterGroundOffset = 45; // Empurra personagem/sombra mais para baixo
    let characterDepthZoom = 1; // 1 = tamanho base (mínimo)
    let targetCharacterDepthZoom = 1;
    let lastDepthZoomChange = 0;
    let characterWidth = 0;
    let characterHeight = 0;
    let imageAspectRatio = 1;
    let walkCycle = 0; // Para animação de caminhada
    let bounceOffset = 0; // Offset vertical suave
    let nextJumpTime = 0;
    let trees = []; // Array de árvores para colisão
    let logoWidth = 0;
    let logoHeight = 0;
    let logoAspectRatio = 1;

    // Seasons + weather (Mode 0)
    const SEASONS = ['spring', 'summer', 'autumn', 'winter'];
    let currentSeason = 'spring';
    let seasonFrom = 'spring';
    let seasonTo = 'spring';
    let seasonTransitionStart = 0;
    const seasonTransitionDurationMs = 15000; // transição suave (15s)
    let nextSeasonChangeAt = 0;

    let weatherType = null; // 'rain' | 'snow' | null
    let weatherStrength = 0;
    let targetWeatherStrength = 0;
    let weatherEndAt = 0;
    let nextWeatherCheckAt = 0;
    let weatherParticles = [];
    let windMultiplier = 1;

    function clamp01(x) {
      return Math.max(0, Math.min(1, x));
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function rgba(r, g, b, a) {
      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
    }

    function seasonWeights() {
      const now = Date.now();
      if (seasonTransitionStart) {
        const t = clamp01((now - seasonTransitionStart) / seasonTransitionDurationMs);
        const w = { spring: 0, summer: 0, autumn: 0, winter: 0 };
        w[seasonFrom] = 1 - t;
        w[seasonTo] = t;
        return w;
      }
      return {
        spring: currentSeason === 'spring' ? 1 : 0,
        summer: currentSeason === 'summer' ? 1 : 0,
        autumn: currentSeason === 'autumn' ? 1 : 0,
        winter: currentSeason === 'winter' ? 1 : 0,
      };
    }

    function pickNextSeason(exclude) {
      const options = SEASONS.filter(s => s !== exclude);
      return options[Math.floor(Math.random() * options.length)];
    }

    function scheduleNextSeasonChange(now) {
      const minMs = 2 * 60 * 1000;
      const maxMs = 20 * 60 * 1000;
      nextSeasonChangeAt = now + (minMs + Math.random() * (maxMs - minMs));
    }

    function updateSeasonAndWeather() {
      const now = Date.now();
      if (!nextSeasonChangeAt) scheduleNextSeasonChange(now);

      // Finish transition
      if (seasonTransitionStart) {
        const t = (now - seasonTransitionStart) / seasonTransitionDurationMs;
        if (t >= 1) {
          currentSeason = seasonTo;
          seasonFrom = currentSeason;
          seasonTransitionStart = 0;
        }
      }

      // Start new season transition
      if (!seasonTransitionStart && now >= nextSeasonChangeAt) {
        seasonFrom = currentSeason;
        seasonTo = pickNextSeason(seasonFrom);
        seasonTransitionStart = now;
        scheduleNextSeasonChange(now);
      }

      // Weather events (climatic)
      const w = seasonWeights();
      const isMostlyWinter = w.winter > 0.6;
      const isMostlySpring = w.spring > 0.6;
      const isMostlyAutumn = w.autumn > 0.6;

      if (now >= nextWeatherCheckAt && !weatherType) {
        // check every 15–45s
        nextWeatherCheckAt = now + (15000 + Math.random() * 30000);

        if (isMostlyWinter && Math.random() < 0.35) {
          weatherType = 'snow';
          targetWeatherStrength = 1;
          weatherEndAt = now + (25000 + Math.random() * 45000);
          initWeatherParticles('snow');
        } else if (isMostlySpring && Math.random() < 0.25) {
          weatherType = 'rain';
          targetWeatherStrength = 1;
          weatherEndAt = now + (18000 + Math.random() * 35000);
          initWeatherParticles('rain');
        } else if (isMostlyAutumn && Math.random() < 0.20) {
          // wind gust event
          windMultiplier = 1.6;
          weatherEndAt = now + (12000 + Math.random() * 20000);
        }
      }

      if (weatherType && now >= weatherEndAt) {
        targetWeatherStrength = 0;
      }
      if (!weatherType && windMultiplier !== 1 && now >= weatherEndAt) {
        windMultiplier = 1;
      }

      // Smooth weather strength
      weatherStrength += (targetWeatherStrength - weatherStrength) * 0.03;
      if (weatherStrength < 0.02) {
        weatherStrength = 0;
        targetWeatherStrength = 0;
        weatherType = null;
        weatherParticles = [];
      }
    }

    function initWeatherParticles(type) {
      weatherParticles = [];
      const count = type === 'rain' ? 220 : 140;
      for (let i = 0; i < count; i++) {
        weatherParticles.push({
          x: (i * 73.1) % canvas.width,
          y: (i * 41.3) % canvas.height,
          vx: ((i % 7) - 3) * (type === 'snow' ? 0.12 : 0.04),
          vy: type === 'rain' ? (6 + (i % 7)) : (0.8 + (i % 6) * 0.15),
          size: type === 'rain' ? (10 + (i % 12)) : (1 + (i % 3)),
        });
      }
    }

    function drawWeather() {
      if (!weatherType || !weatherStrength || weatherParticles.length === 0) return;
      const strength = weatherStrength;
      ctx.save();
      ctx.globalAlpha = 0.9 * strength;

      if (weatherType === 'rain') {
        ctx.strokeStyle = 'rgba(200, 230, 255, 0.6)';
        ctx.lineWidth = 1.2;
        weatherParticles.forEach(p => {
          p.x += (p.vx * 20) * strength;
          p.y += (p.vy * 3) * strength;
          if (p.y > canvas.height + 30) {
            p.y = -30;
            p.x = (p.x + canvas.width * 0.37) % canvas.width;
          }
          if (p.x < -40) p.x = canvas.width + 40;
          if (p.x > canvas.width + 40) p.x = -40;

          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - 6, p.y - p.size);
          ctx.stroke();
        });
      } else if (weatherType === 'snow') {
        weatherParticles.forEach(p => {
          p.x += (p.vx * 10) * strength;
          p.y += (p.vy * 2) * strength;
          if (p.y > canvas.height + 10) {
            p.y = -10;
            p.x = (p.x + canvas.width * 0.29) % canvas.width;
          }
          if (p.x < -20) p.x = canvas.width + 20;
          if (p.x > canvas.width + 20) p.x = -20;

          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      ctx.restore();
    }
    
    function initGarden() {
      canvas = document.getElementById('gardenCanvas');
      if (!canvas) return;
      
      ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundLevel = canvas.height * 0.80; // Jardim ocupa mais altura (80% da altura = mais espaço para jardim)
      
      // Load character image
      characterImg = new Image();
      characterImg.src = 'https://mewvolt.online/character.png';
      
      // Load logo image
      logoImg = new Image();
      logoImg.src = 'https://mewvolt.online/logo.png';
      
      let characterLoaded = false;
      let logoLoaded = false;
      
      characterImg.onload = () => {
        // Calcular proporção da imagem
        imageAspectRatio = characterImg.width / characterImg.height;
        // Definir altura base e calcular largura mantendo proporção
        characterHeight = 120;
        characterWidth = characterHeight * imageAspectRatio;
        characterY = groundLevel - characterHeight + characterGroundOffset;
        characterLoaded = true;
        if (characterLoaded && logoLoaded) {
          nextJumpTime = Date.now() + 3000 + Math.random() * 2000;
          animateGarden();
        }
      };
      
      logoImg.onload = () => {
        // Calcular proporção do logo
        logoAspectRatio = logoImg.width / logoImg.height;
        // Tamanho do logo (pode ajustar)
        logoHeight = 200;
        logoWidth = logoHeight * logoAspectRatio;
        logoLoaded = true;
        if (characterLoaded && logoLoaded) {
          nextJumpTime = Date.now() + 3000 + Math.random() * 2000;
          animateGarden();
        }
      };
      
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        groundLevel = canvas.height * 0.80; // Jardim ocupa mais altura
        if (characterImg.complete) {
          characterY = groundLevel - characterHeight + characterGroundOffset;
        }
        // Reinicializar árvores ao redimensionar
        initTrees();
      });
      
      // Inicializar árvores e partículas
      initTrees();
      initParticles();
    }
    
    function drawGarden() {
      updateSeasonAndWeather();
      const time = Date.now() / 1000;
      const w = seasonWeights();
      
      // Sky gradient mais realista (céu azul que vai para verde)
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#6BB6FF'); // Azul céu mais realista
      gradient.addColorStop(0.4, '#87CEEB'); // Azul claro
      gradient.addColorStop(0.65, '#A8E6CF'); // Verde claro
      gradient.addColorStop(0.85, '#C8E6C9'); // Verde
      gradient.addColorStop(1, '#AED581'); // Verde grama
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Seasonal tint overlay (suave, sem alterar o design todo)
      const tintR = (w.summer * 255 + w.spring * 235 + w.autumn * 255 + w.winter * 210);
      const tintG = (w.summer * 240 + w.spring * 255 + w.autumn * 205 + w.winter * 235);
      const tintB = (w.summer * 220 + w.spring * 235 + w.autumn * 160 + w.winter * 255);
      const tintA = (w.summer * 0.06 + w.spring * 0.04 + w.autumn * 0.10 + w.winter * 0.14);
      ctx.fillStyle = rgba(tintR, tintG, tintB, tintA);
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Sun (sol animado)
      const sunX = canvas.width * 0.85;
      const sunY = canvas.height * 0.25;
      const sunSize = 80 + Math.sin(time * 0.5) * 5;
      const sunGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunSize);
      sunGradient.addColorStop(0, '#FFF9C4');
      sunGradient.addColorStop(0.7, '#FFEB3B');
      sunGradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Clouds (mais realistas e animadas)
      drawClouds();
      
      // Hills/terrain no background (colinas suaves)
      ctx.fillStyle = '#81C784';
      ctx.beginPath();
      ctx.moveTo(0, groundLevel);
      for (let i = 0; i < canvas.width; i += 10) {
        const hillHeight = Math.sin((i / canvas.width) * Math.PI * 4 + time * 0.1) * 15;
        ctx.lineTo(i, groundLevel - hillHeight - 40);
      }
      ctx.lineTo(canvas.width, groundLevel);
      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.closePath();
      ctx.fill();
      
      // Ground/grass (camada principal)
      ctx.fillStyle = '#66BB6A';
      ctx.fillRect(0, groundLevel - 30, canvas.width, canvas.height - groundLevel + 30);

      // Winter snow cover on the ground
      const snowCover = w.winter * 0.55;
      if (snowCover > 0.01) {
        ctx.fillStyle = `rgba(255, 255, 255, ${snowCover})`;
        ctx.fillRect(0, groundLevel - 34, canvas.width, canvas.height - groundLevel + 34);
      }
      
      // Grass detalhada e animada (múltiplas camadas) - mais densa
      drawAnimatedGrass();
      
      // Trees atrás do character (apenas as que estão atrás)
      drawTreesBehind();
      
      // Logo no centro
      drawLogo();
    }
    
    // Desenhar árvores que estão na frente do character (z-index maior)
    function drawTreesFront() {
      const time = Date.now() / 1200;
      
      if (trees.length === 0) {
        initTrees();
      }
      
      // Filtrar árvores que estão na frente do character (baseado na posição X)
      const characterCenterX = characterX + characterWidth / 2;
      const frontTrees = trees.filter(tree => tree.x > characterCenterX);
      
      frontTrees.forEach((tree) => {
        const treeY = groundLevel - 150; // Árvores mais para cima
        const treeIndex = trees.indexOf(tree); // Índice fixo no array original
        const sway = Math.sin(time + treeIndex) * 2;
        
        drawSingleTree(tree, treeY, sway, time, treeIndex);
      });
    }
    
    // Desenhar árvores que estão atrás do character
    function drawTreesBehind() {
      const time = Date.now() / 1200;
      
      if (trees.length === 0) {
        initTrees();
      }
      
      // Filtrar árvores que estão atrás do character
      const characterCenterX = characterX + characterWidth / 2;
      const behindTrees = trees.filter(tree => tree.x <= characterCenterX);
      
      behindTrees.forEach((tree) => {
        const treeY = groundLevel - 150; // Árvores mais para cima
        const treeIndex = trees.indexOf(tree); // Índice fixo no array original
        const sway = Math.sin(time + treeIndex) * 2;
        
        drawSingleTree(tree, treeY, sway, time, treeIndex);
      });
    }
    
    function drawClouds() {
      const time = Date.now() / 4000; // Movimento mais lento e suave
      
      // Múltiplas camadas de nuvens (background, mid, front)
      const cloudLayers = [
        { count: 3, speed: 0.3, opacity: 0.4, yBase: 30, sizeBase: 80 },
        { count: 4, speed: 0.5, opacity: 0.6, yBase: 60, sizeBase: 60 },
        { count: 5, speed: 0.7, opacity: 0.8, yBase: 100, sizeBase: 50 }
      ];
      
      cloudLayers.forEach(layer => {
        ctx.fillStyle = `rgba(255, 255, 255, ${layer.opacity})`;
        for (let i = 0; i < layer.count; i++) {
          const x = (canvas.width / layer.count * i + time * layer.speed * 30) % (canvas.width + 250) - 125;
          const y = layer.yBase + i * 35 + Math.sin(time + i) * 10;
          const size = layer.sizeBase + i * 8;
          drawRealisticCloud(x, y, size, time + i);
        }
      });
    }
    
    function drawRealisticCloud(x, y, size, timeOffset) {
      ctx.save();
      ctx.translate(x, y);
      
      // Nuvem mais realista com múltiplos círculos sobrepostos
      const circles = [
        { x: 0, y: 0, r: size * 0.5 },
        { x: size * 0.4, y: 0, r: size * 0.6 },
        { x: size * 0.7, y: 0, r: size * 0.5 },
        { x: size * 0.25, y: -size * 0.25, r: size * 0.45 },
        { x: size * 0.6, y: -size * 0.25, r: size * 0.4 },
        { x: size * 0.45, y: -size * 0.4, r: size * 0.35 }
      ];
      
      // Sway suave (balanço)
      const sway = Math.sin(timeOffset * 0.5) * 3;
      
      circles.forEach(circle => {
        ctx.beginPath();
        ctx.arc(circle.x + sway, circle.y, circle.r, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.restore();
    }
    
    function drawAnimatedGrass() {
      const time = Date.now() / 800;
      
      // Camada 1: Grama alta (mais densa)
      ctx.strokeStyle = '#558B2F';
      for (let i = 0; i < canvas.width; i += 4) { // Mais frequente (era 8)
        const wind = Math.sin(time + i * 0.1) * 8;
        const grassHeight = 15 + Math.sin(i * 0.3) * 5;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(i, groundLevel);
        ctx.quadraticCurveTo(i + wind * 0.5, groundLevel - grassHeight * 0.5, i + wind, groundLevel - grassHeight);
        ctx.stroke();
      }
      
      // Camada 2: Grama média (mais densa)
      ctx.strokeStyle = '#66BB6A';
      for (let i = 2; i < canvas.width; i += 6) { // Mais frequente (era 12)
        const wind = Math.sin(time * 1.2 + i * 0.15) * 6;
        const grassHeight = 10 + Math.cos(i * 0.4) * 3;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(i, groundLevel);
        ctx.quadraticCurveTo(i + wind * 0.4, groundLevel - grassHeight * 0.5, i + wind * 0.8, groundLevel - grassHeight);
        ctx.stroke();
      }
      
      // Camada 3: Grama baixa (detalhes - mais densa)
      ctx.strokeStyle = '#81C784';
      for (let i = 1; i < canvas.width; i += 8) { // Mais frequente (era 15)
        const wind = Math.sin(time * 0.8 + i * 0.2) * 4;
        const grassHeight = 6 + Math.sin(i) * 2;
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(i, groundLevel);
        ctx.lineTo(i + wind * 0.3, groundLevel - grassHeight);
        ctx.stroke();
      }
      
      // Camada 4: Grama extra fina (mais detalhes)
      ctx.strokeStyle = '#AED581';
      for (let i = 1.5; i < canvas.width; i += 5) {
        const wind = Math.sin(time * 0.9 + i * 0.25) * 3;
        const grassHeight = 4 + Math.cos(i * 0.6) * 1.5;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(i, groundLevel);
        ctx.lineTo(i + wind * 0.2, groundLevel - grassHeight);
        ctx.stroke();
      }
    }
    
    // Partículas animadas (pólen, folhas, etc)
    let particles = [];
    function initParticles() {
      particles = [];
      for (let i = 0; i < 30; i++) {
        // Cores fixas baseadas no índice (sem Math.random para evitar tremores)
        const colorSeed = i * 17;
        let colorR, colorG, colorB;
        const type = (i % 10 > 7) ? 'leaf' : 'pollen'; // Folhas ou pólen
        
        if (type === 'leaf') {
          colorR = 50 + (colorSeed % 30);
          colorG = 150 + ((colorSeed * 7) % 40);
          colorB = 80 + ((colorSeed * 13) % 20);
        } else {
          colorR = 255;
          colorG = 200 + (colorSeed % 50);
          colorB = colorSeed % 100;
        }
        
        particles.push({
          x: (i * 47.3) % canvas.width, // Posições determinísticas
          y: (i * 31.7) % (canvas.height * 0.6),
          vx: ((i * 0.1) % 1 - 0.5) * 0.5,
          vy: (i * 0.07) % 0.3 + 0.1,
          size: (i * 0.13) % 3 + 1,
          type: type,
          rotation: (i * 0.52) % (Math.PI * 2),
          rotationSpeed: ((i * 0.03) % 1 - 0.5) * 0.05,
          colorR: colorR,
          colorG: colorG,
          colorB: colorB
        });
      }
    }
    
    function drawParticles() {
      if (particles.length === 0 && canvas) {
        initParticles();
      }
      
      const time = Date.now() / 1000;
      const w = seasonWeights();
      const pollenFactor = clamp01(w.spring + w.summer * 0.6);
      const leafFactor = clamp01(w.autumn + w.winter * 0.25);
      
      particles.forEach((particle, idx) => {
        // Atualizar posição (vento afeta mais folhas/pólen)
        const wind = windMultiplier || 1;
        particle.x += particle.vx * wind;
        particle.y += particle.vy;
        particle.rotation += particle.rotationSpeed;
        
        // Resetar se sair da tela (posição determinística baseada no índice)
        if (particle.y > groundLevel + 50) {
          const idx = particles.indexOf(particle);
          particle.y = -20;
          particle.x = (idx * 47.3) % canvas.width; // Posição determinística
        }
        if (particle.x < -10) particle.x = canvas.width + 10;
        if (particle.x > canvas.width + 10) particle.x = -10;
        
        // Desenhar partícula
        ctx.save();
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation);
        
        if (particle.type === 'leaf') {
          if (leafFactor < 0.05 && (idx % 2 === 0)) {
            ctx.restore();
            return;
          }
          // Folha caindo (cores fixas armazenadas)
          const a = 0.15 + 0.55 * leafFactor;
          ctx.fillStyle = `rgba(${particle.colorR}, ${particle.colorG}, ${particle.colorB}, ${a})`;
          ctx.beginPath();
          ctx.ellipse(0, 0, particle.size * 2, particle.size, 0, 0, Math.PI * 2);
          ctx.fill();
        } else {
          if (pollenFactor < 0.05 && (idx % 2 === 1)) {
            ctx.restore();
            return;
          }
          // Pólen (cores fixas armazenadas)
          const a = 0.12 + 0.45 * pollenFactor;
          ctx.fillStyle = `rgba(${particle.colorR}, ${particle.colorG}, ${particle.colorB}, ${a})`;
          ctx.beginPath();
          ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
          ctx.fill();
          // Brilho do pólen
          ctx.fillStyle = `rgba(255, 255, 200, ${0.12 + 0.22 * pollenFactor})`;
          ctx.beginPath();
          ctx.arc(0, 0, particle.size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      });
    }
    
    function drawFlowers() {
      const time = Date.now() / 1000;
      const w = seasonWeights();
      const flowerFactor = clamp01(w.spring + w.summer * 0.65);
      if (flowerFactor < 0.08) return;
      // Mais flores pelo cenário
      const flowers = [
        { x: canvas.width * 0.12, y: groundLevel, color: 15, size: 1.0 },
        { x: canvas.width * 0.18, y: groundLevel, color: 45, size: 1.1 },
        { x: canvas.width * 0.25, y: groundLevel, color: 60, size: 0.9 },
        { x: canvas.width * 0.32, y: groundLevel, color: 30, size: 1.2 },
        { x: canvas.width * 0.42, y: groundLevel, color: 320, size: 0.95 },
        { x: canvas.width * 0.52, y: groundLevel, color: 340, size: 1.0 },
        { x: canvas.width * 0.62, y: groundLevel, color: 280, size: 1.15 },
        { x: canvas.width * 0.72, y: groundLevel, color: 260, size: 0.85 },
        { x: canvas.width * 0.82, y: groundLevel, color: 350, size: 1.05 },
        { x: canvas.width * 0.88, y: groundLevel, color: 200, size: 0.9 },
        { x: canvas.width * 0.38, y: groundLevel, color: 50, size: 0.8 },
        { x: canvas.width * 0.58, y: groundLevel, color: 300, size: 1.1 },
      ];
      
      flowers.forEach((flower, idx) => {
        // Reduz quantidade quando não é primavera/verão
        if (flowerFactor < 0.35 && (idx % 2 === 1)) return;
        // Sway com vento
        const sway = Math.sin(time * 0.8 + idx) * 3;
        const flowerX = flower.x + sway;
        
        // Stem (caule mais realista com curvatura)
        ctx.strokeStyle = `rgba(46, 125, 50, ${0.55 + 0.45 * flowerFactor})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(flowerX, flower.y);
        ctx.quadraticCurveTo(flowerX + sway * 0.3, flower.y - 20, flowerX, flower.y - 40);
        ctx.stroke();
        
        // Leaves (folhas no caule)
        ctx.fillStyle = `rgba(76, 175, 80, ${0.55 + 0.45 * flowerFactor})`;
        ctx.beginPath();
        ctx.ellipse(flowerX - 5, flower.y - 20, 6, 3, sway * 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Petals (pétalas animadas e rotacionadas)
        const rotation = time * 0.3 + idx;
        const petalCount = 6;
        const petalSize = 10 * flower.size;
        const petalDistance = 18 * flower.size;
        
        ctx.fillStyle = `hsla(${(flower.color + time * 20) % 360}, 75%, 65%, ${0.45 + 0.55 * flowerFactor})`;
        for (let i = 0; i < petalCount; i++) {
          const angle = (Math.PI * 2 / petalCount) * i + rotation;
          const px = flowerX + Math.cos(angle) * petalDistance;
          const py = flower.y - 40 + Math.sin(angle) * petalDistance;
          
          // Pétala elíptica
          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.ellipse(0, 0, petalSize, petalSize * 0.6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        // Center (centro da flor)
        ctx.fillStyle = `rgba(255, 215, 0, ${0.55 + 0.45 * flowerFactor})`;
        ctx.beginPath();
        ctx.arc(flowerX, flower.y - 40, 7 * flower.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Detalhe do centro
        ctx.fillStyle = `rgba(255, 160, 0, ${0.55 + 0.45 * flowerFactor})`;
        ctx.beginPath();
        ctx.arc(flowerX, flower.y - 40, 4 * flower.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    function initTrees() {
      // Inicializar árvores em posições variadas (mais árvores, mais realista)
      trees = [
        { x: canvas.width * 0.05, size: 85, height: 130, trunkWidth: 32 },
        { x: canvas.width * 0.15, size: 100, height: 150, trunkWidth: 36 },
        { x: canvas.width * 0.32, size: 75, height: 120, trunkWidth: 28 },
        { x: canvas.width * 0.48, size: 95, height: 140, trunkWidth: 34 },
        { x: canvas.width * 0.65, size: 80, height: 125, trunkWidth: 30 },
        { x: canvas.width * 0.80, size: 105, height: 155, trunkWidth: 38 },
        { x: canvas.width * 0.93, size: 90, height: 135, trunkWidth: 32 },
      ];
    }
    
    // Função auxiliar para desenhar uma árvore individual
    function drawSingleTree(tree, treeY, sway, time, idx) {
        // Trunk (tronco mais realista com textura e profundidade)
        const trunkHalf = tree.trunkWidth / 2;
        const trunkGradient = ctx.createLinearGradient(
          tree.x - trunkHalf, treeY, 
          tree.x + trunkHalf, treeY + tree.height
        );
        trunkGradient.addColorStop(0, '#5D4037');
        trunkGradient.addColorStop(0.3, '#6D4C41');
        trunkGradient.addColorStop(0.7, '#5D4037');
        trunkGradient.addColorStop(1, '#4E342E');
        ctx.fillStyle = trunkGradient;
        ctx.fillRect(tree.x - trunkHalf + sway * 0.1, treeY, tree.trunkWidth, tree.height);
        
        // Trunk details (textura mais realista)
        ctx.strokeStyle = '#3E2723';
        ctx.lineWidth = 1.5;
        // Linhas verticais de textura (valores fixos baseados no índice da árvore para evitar tremores)
        const textureSeed = tree.x * 0.01 + idx * 0.1; // Seed baseado na posição X e índice
        for (let i = 0; i < 4; i++) {
          const offset = (i / 3) * tree.trunkWidth - trunkHalf;
          // Usar seed determinístico em vez de Math.random()
          const textureOffset = Math.sin(textureSeed + i) * 0.8; // Valor fixo mas variado
          ctx.beginPath();
          ctx.moveTo(tree.x + offset + sway * 0.1, treeY);
          ctx.lineTo(tree.x + offset + sway * 0.1 + textureOffset, treeY + tree.height);
          ctx.stroke();
        }
        
        // Anéis do tronco (sugestão de idade)
        ctx.strokeStyle = 'rgba(62, 39, 35, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 1; i < 4; i++) {
          ctx.beginPath();
          ctx.arc(tree.x + sway * 0.1, treeY + (tree.height / 4) * i, trunkHalf * 0.8, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Leaves (folhas mais realistas com múltiplas camadas e variações)
        const leafBaseY = treeY - tree.height * 0.3;
        const leafColors = [
          { light: '#81C784', mid: '#66BB6A', dark: '#4CAF50' },
          { light: '#A5D6A7', mid: '#81C784', dark: '#66BB6A' },
          { light: '#C8E6C9', mid: '#A5D6A7', dark: '#81C784' }
        ];
        const colorSet = leafColors[idx % leafColors.length];
        
        // Camada de folhas principal (forma mais orgânica)
        const mainLeafGradient = ctx.createRadialGradient(
          tree.x + sway, leafBaseY, 0,
          tree.x + sway, leafBaseY, tree.size
        );
        mainLeafGradient.addColorStop(0, colorSet.light);
        mainLeafGradient.addColorStop(0.6, colorSet.mid);
        mainLeafGradient.addColorStop(1, colorSet.dark);
        ctx.fillStyle = mainLeafGradient;
        
        // Folhas em múltiplas camadas (forma mais natural)
        const leafLayers = [
          { x: tree.x + sway, y: leafBaseY, size: tree.size, offset: 0 },
          { x: tree.x - tree.size * 0.35 + sway * 0.85, y: leafBaseY - tree.size * 0.2, size: tree.size * 0.8, offset: -0.1 },
          { x: tree.x + tree.size * 0.35 + sway * 0.85, y: leafBaseY - tree.size * 0.2, size: tree.size * 0.8, offset: 0.1 },
          { x: tree.x + sway * 0.7, y: leafBaseY - tree.size * 0.45, size: tree.size * 0.65, offset: 0 },
          { x: tree.x - tree.size * 0.25 + sway * 0.75, y: leafBaseY - tree.size * 0.35, size: tree.size * 0.7, offset: -0.15 },
          { x: tree.x + tree.size * 0.25 + sway * 0.75, y: leafBaseY - tree.size * 0.35, size: tree.size * 0.7, offset: 0.15 }
        ];
        
        leafLayers.forEach((leaf, leafIdx) => {
          // Gradiente para cada camada de folhas
          const leafGrad = ctx.createRadialGradient(
            leaf.x, leaf.y, leaf.size * 0.2,
            leaf.x, leaf.y, leaf.size
          );
          leafGrad.addColorStop(0, colorSet.light);
          leafGrad.addColorStop(0.7, colorSet.mid);
          leafGrad.addColorStop(1, colorSet.dark);
          ctx.fillStyle = leafGrad;
          
          // Desenhar folhas em forma mais orgânica (elipse ou círculo levemente distorcido)
          ctx.save();
          ctx.translate(leaf.x, leaf.y);
          ctx.rotate(leaf.offset * 0.2);
          ctx.beginPath();
          ctx.ellipse(0, 0, leaf.size, leaf.size * 0.95, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          // Highlights nas folhas (brilho do sol)
          if (leafIdx < 3) { // Só nas camadas superiores
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.ellipse(
              leaf.x - leaf.size * 0.35, 
              leaf.y - leaf.size * 0.35, 
              leaf.size * 0.35, 
              leaf.size * 0.25, 
              0.3, 0, Math.PI * 2
            );
            ctx.fill();
          }
        });
    }
    
    function drawLogo() {
      if (!logoImg.complete || !logoAspectRatio) return;
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2 - 100; // Um pouco acima do centro
      
      // Glow effect (brilho suave)
      const time = Date.now() / 1000;
      const glowIntensity = 0.3 + Math.sin(time * 2) * 0.1;
      const glowSize = logoWidth * 1.2;
      
      // Sombra/glow atrás do logo
      const gradient = ctx.createRadialGradient(
        centerX, centerY, logoWidth * 0.3,
        centerX, centerY, glowSize
      );
      gradient.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.3})`);
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Bounce suave sutil
      const bounce = Math.sin(time * 1.5) * 3;
      
      ctx.save();
      ctx.translate(centerX, centerY + bounce);
      
      // Draw logo mantendo proporção
      ctx.drawImage(logoImg, -logoWidth/2, -logoHeight/2, logoWidth, logoHeight);
      ctx.restore();
    }
    
    function drawCharacter() {
      if (!characterImg.complete || !imageAspectRatio) return;
      
      const drawX = characterX;
      const drawY = characterY;
      
      // Calcular altura do pulo (quanto mais alto, menor a sombra)
      const groundY = groundLevel - characterHeight + characterGroundOffset;
      const jumpHeight = groundY - characterY; // Positivo quando está acima do chão
      const maxJumpHeight = 150; // Altura máxima estimada do pulo
      const heightRatio = Math.max(0, Math.min(1, jumpHeight / maxJumpHeight)); // 0 = no chão, 1 = máximo
      
      // Shadow diminui quando salta (quanto mais alto, menor e mais transparente)
      const baseShadowSize = characterWidth * 0.35 * characterDepthZoom;
      const shadowSize = baseShadowSize * (1 - heightRatio * 0.6); // Reduz até 60% quando no máximo
      const shadowOpacity = 0.18 * (1 - heightRatio * 0.7); // Opacidade reduz até 70% quando no máximo
      
      ctx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
      ctx.beginPath();
      const zoomNow = Math.max(1, Number(characterDepthZoom) || 1);
      const depthOffsetY = (zoomNow - 1) * characterHeight * 0.55; // mais zoom => mais para baixo
      const shadowY = groundLevel + characterGroundOffset - 16 + depthOffsetY;
      ctx.ellipse(characterX + characterWidth/2, shadowY, shadowSize, shadowSize * 0.22, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Bounce suave contínuo (passo animado)
      const time = Date.now() / 500;
      walkCycle = (walkCycle + 0.1) % (Math.PI * 2);
      const walkBounce = Math.abs(Math.sin(walkCycle)) * 1.0; // Bounce mínimo (mais junto à sombra)
      bounceOffset = isJumping ? 0 : walkBounce;
      
      // Rotation suave ao pular (mais animado)
      let rotation = 0;
      if (isJumping && characterVy < 0) {
        rotation = characterVx < 0 ? -0.1 : 0.1; // Inclina ao pular
      }

      // Efeito de respirar (scale suave) + efeito de "aproximar da câmara" (depth zoom)
      const breatheTime = Date.now() / 1000;
      const breathe = 1 + Math.sin(breatheTime * 2.0) * 0.02; // ~2%
      const zoom = zoomNow;
      const finalScale = breathe * zoom;

      ctx.save();
      // Ancorar o sprite pelos pés; quando faz zoom, desce um pouco para dar sensação de aproximar da câmara
      ctx.translate(drawX + characterWidth/2, drawY + characterHeight - bounceOffset + depthOffsetY);

      // Aplicar rotação em torno do centro do corpo (sem deslocar os pés)
      if (rotation !== 0) {
        ctx.translate(0, -characterHeight/2);
        ctx.rotate(rotation);
        ctx.translate(0, characterHeight/2);
      }

      // Flip horizontal conforme direção:
      // - imagem original está virada para a esquerda
      // - por defeito (andar para a direita) espelhamos para ele olhar para a direita
      const flipScaleX = characterVx >= 0 ? -1 : 1;
      ctx.scale(flipScaleX * finalScale, finalScale);
      
      // Draw character mantendo proporção (desenhar a partir dos pés)
      ctx.drawImage(characterImg, -characterWidth/2, -characterHeight, characterWidth, characterHeight);
      ctx.restore();
      
      // Efeito de "happy bounce" - bounce extra quando não está pulando
      if (!isJumping && Math.random() < 0.01) {
        // Pequeno bounce aleatório
      }
    }
    
    function updateCharacter() {
      // Ajustar zoom de profundidade (smooth) — nunca menor que o tamanho inicial
      const nowZoom = Date.now();
      const minZoom = 1;
      // Troca ocasional quando está a caminhar (não durante saltos)
      if (!isJumping && nowZoom - lastDepthZoomChange > 5000 && Math.random() < 0.004) {
        // Alternar entre voltar ao normal e aproximar-se
        targetCharacterDepthZoom = (targetCharacterDepthZoom > 1.02) ? 1 : (1.10 + Math.random() * 0.18); // 1.10–1.28
        lastDepthZoomChange = nowZoom;
      }
      // Interpolação suave
      characterDepthZoom += (targetCharacterDepthZoom - characterDepthZoom) * 0.02;
      if (characterDepthZoom < minZoom) characterDepthZoom = minZoom;

      // Mover character sem colisões (personagem sempre por cima das árvores)
      characterX += characterVx;
      
      // Bounce at edges com delay (pausa antes de virar)
      const margin = 60;
      // Considerar o zoom ao calcular limites (evita cortar sprite nas bordas)
      const z = Math.max(1, Number(characterDepthZoom) || 1);
      const leftBound = margin + (characterWidth * (z - 1)) / 2;
      const rightBound = canvas.width - margin - (characterWidth * (z + 1)) / 2;
      if (characterX < leftBound) {
        characterX = leftBound;
        characterVx = Math.abs(characterVx); // Vira para direita
        // Pequeno bounce ao bater na parede
        if (!isJumping && Math.random() < 0.3) {
          isJumping = true;
          characterVy = -8;
        }
      } else if (characterX > rightBound) {
        characterX = rightBound;
        characterVx = -Math.abs(characterVx); // Vira para esquerda
        // Pequeno bounce ao bater na parede
        if (!isJumping && Math.random() < 0.3) {
          isJumping = true;
          characterVy = -8;
        }
      }
      
      // Jumping mechanics - mais frequente e variado
      const now = Date.now();
      if (!isJumping && now >= nextJumpTime) {
        isJumping = true;
        // Velocidade de pulo variável (mais animado)
        characterVy = -12 - Math.random() * 4; // Entre -12 e -16
        nextJumpTime = now + 2000 + Math.random() * 3000; // Próximo pulo em 2-5s
      }
      
      if (isJumping) {
        characterY += characterVy;
        characterVy += 0.6; // Gravity mais suave
        
        // Aterrissar
        const groundY = groundLevel - characterHeight + characterGroundOffset;
        if (characterY >= groundY) {
          characterY = groundY;
          characterVy = 0;
          isJumping = false;
        }
      }
      
      // Pequenas variações de velocidade (mais orgânico)
      if (!isJumping && Math.random() < 0.02) {
        characterVx *= (0.95 + Math.random() * 0.1); // Variação sutil
      }
    }
    
    function animateGarden() {
      if (!canvas || !ctx) return;
      
      drawGarden(); // Desenha background e árvores atrás
      updateCharacter();
      drawTreesFront(); // Desenha árvores na frente
      drawFlowers(); // Desenha flores por cima das árvores
      drawParticles(); // Desenha partículas (pólen, folhas, etc)
      drawWeather(); // Chuva/neve por cima do cenário
      drawCharacter(); // Desenha character por cima de tudo (z-index maior)
      
      requestAnimationFrame(animateGarden);
    }

    // Initialize
    function init() {
      // Start intervals
      fetchAllCoinData(); // Initial call - busca tudo
      loadTasks();

      // Atualizar informações da moeda a cada 10 segundos
      fetchAllCoinData(); // Initial call
      viewersInterval = setInterval(fetchAllCoinData, 10000); // 10 segundos
      priceInterval = null; // Integrado em fetchAllCoinData
      tasksInterval = setInterval(loadTasks, 10000); // 10 segundos
      
      // Atualizar comentários a cada 8 segundos (mais frequente) - mode-1 e mode-2
      if (pageId === '1' || pageId === '2') {
        fetchLiveComments();
        commentsInterval = setInterval(fetchLiveComments, 8000);
      }
      
      // Buscar transações do Solscan para detectar compras (todas as páginas)
      if (CONFIG.enableSolscanPolling) {
        fetchSolscanTransactions();
        solscanInterval = setInterval(fetchSolscanTransactions, 8000); // A cada 8 segundos
      }

      // Connect WebSocket
      connectWS();
      
      // Connect to Chat WebSocket (TODOS os modos para processar comandos)
      connectChatWS();
      
      // Initialize garden if mode 0
      if (pageId === '0' || !pageId) {
        initGarden();
      }
    }

    // Start on load
    window.addEventListener('load', init);

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (ws) ws.close();
      if (chatSocket) chatSocket.disconnect();
      if (viewersInterval) clearInterval(viewersInterval);
      if (priceInterval) clearInterval(priceInterval);
      if (tasksInterval) clearInterval(tasksInterval);
      if (commentsInterval) clearInterval(commentsInterval);
      if (solscanInterval) clearInterval(solscanInterval);
    });
  </script>
</body>
</html>