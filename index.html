<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MewVolt Elite Casino Overlay</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Montserrat:wght@800&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Palette Premium BET */
      --bg-dark: #07080a;
      --panel-bg: rgba(12, 14, 18, 0.96);
      --neon-green: #00ff73;
      --neon-pink: #ff2975;
      --neon-blue: #00d2ff;
      --gold: #ffcc00;
      --glass-border: rgba(255, 255, 255, 0.08);
      --reel-bg: #050608;
      --text-main: #ffffff;
      --text-muted: #666666;
      --radius: 24px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; background: transparent; overflow: hidden; }
    body { font-family: 'Inter', sans-serif; color: var(--text-main); }

    /* --- BACKGROUND CANVAS --- */
    .gardenCanvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
    }

    /* --- HUD LAYOUT (MODE 3) --- */
    .hudContainer {
      position: fixed;
      inset: 0;
      display: none; /* Ativado via JS no mode-3 */
      grid-template-columns: 1fr 360px;
      grid-template-rows: 1fr auto;
      gap: 20px;
      padding: 30px 30px 30px 30px;
      padding-bottom: 0;
      z-index: 1000;
      pointer-events: none;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .hudContainer > * { pointer-events: auto; }
    
    .hudContainer > main,
    .hudContainer > aside {
      grid-row: 1;
      min-height: 0;
    }
    
    .hudContainer > footer {
      grid-column: 1 / -1;
      grid-row: 2;
      margin-top: 0;
      margin-left: -30px;
      margin-right: -30px;
      padding-bottom: 0;
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      visibility: visible;
      opacity: 1;
      width: calc(100% + 60px);
    }

    /* --- SLOT MACHINE HUD (LEFT) --- */
    .slotMachineHud {
      background: var(--panel-bg);
      backdrop-filter: blur(15px);
      border-radius: var(--radius);
      border: 1px solid var(--glass-border);
      display: flex;
      flex-direction: column;
      box-shadow: 0 40px 100px rgba(0,0,0,0.8);
      overflow: hidden;
      position: relative;
    }

    .slot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 25px 35px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid var(--glass-border);
    }

    .casino-brand {
      font-family: 'Montserrat', sans-serif;
      font-size: 22px;
      letter-spacing: 3px;
      font-weight: 900;
      background: linear-gradient(90deg, #fff, var(--neon-blue));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .jackpot-pill {
      background: linear-gradient(90deg, var(--gold), #d4a017);
      padding: 8px 24px;
      border-radius: 50px;
      color: #000;
      font-weight: 900;
      font-size: 14px;
      box-shadow: 0 0 25px rgba(255, 204, 0, 0.3);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .slot-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .status-box {
      background: rgba(255,255,255,0.02);
      border: 1px dashed rgba(255,255,255,0.1);
      padding: 15px 50px;
      border-radius: 15px;
      margin-bottom: 30px;
      text-align: center;
    }
    .status-box span { color: var(--neon-blue); font-family: monospace; font-size: 20px; font-weight: bold; }

    /* Slots Styling */
    .reels-container {
      display: flex;
      gap: 20px;
      position: relative;
    }

    .reel {
      width: 140px;
      height: 420px;
      background: linear-gradient(180deg, #0a0c0f 0%, #050608 50%, #0a0c0f 100%);
      border-radius: 16px;
      border: 3px solid rgba(255,255,255,0.08);
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      align-items: center;
      box-shadow: inset 0 0 50px rgba(0,0,0,0.9);
      position: relative;
      transition: all 0.3s ease;
      overflow: hidden;
    }

    .reel::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.05) 50%, 
        transparent 100%);
      pointer-events: none;
      z-index: 1;
    }

    .symbol { 
      font-size: 48px; 
      font-weight: 900;
      color: rgba(255,255,255,0.1); 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      position: relative;
      z-index: 2;
      transform: scale(0.9);
    }
    
    .symbol.active { 
      color: #fff; 
      transform: scale(1.15);
      text-shadow: 
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 60px currentColor;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .symbol.points { 
      color: var(--neon-green); 
      text-shadow: 
        0 0 25px var(--neon-green),
        0 0 50px var(--neon-green),
        0 0 75px var(--neon-green);
    }
    
    .symbol.jackpot { 
      color: var(--neon-pink); 
      text-shadow: 
        0 0 25px var(--neon-pink),
        0 0 50px var(--neon-pink),
        0 0 75px var(--neon-pink);
    }
    
    .symbol.nft { 
      color: var(--neon-blue); 
      text-shadow: 
        0 0 25px var(--neon-blue),
        0 0 50px var(--neon-blue),
        0 0 75px var(--neon-blue);
    }
    
    .symbol.extra { 
      color: var(--gold); 
      text-shadow: 
        0 0 25px var(--gold),
        0 0 50px var(--gold),
        0 0 75px var(--gold);
    }
    
    .symbol.empty { 
      color: rgba(255, 255, 255, 0.15); 
    }
    
    .reel.spinning {
      overflow: hidden;
      border-color: var(--neon-blue);
      box-shadow: 
        0 0 30px rgba(0, 210, 255, 0.6),
        0 0 60px rgba(0, 210, 255, 0.4),
        inset 0 0 30px rgba(0, 210, 255, 0.2);
      animation: reelShake 0.15s linear infinite;
      transform: perspective(1000px) rotateX(3deg);
    }

    @keyframes reelShake {
      0%, 100% { transform: perspective(1000px) rotateX(3deg) translateX(0); }
      25% { transform: perspective(1000px) rotateX(3deg) translateX(-2px); }
      75% { transform: perspective(1000px) rotateX(3deg) translateX(2px); }
    }
    
    .reel.spinning .symbol {
      animation: symbolSpin 0.12s linear infinite;
      color: rgba(255, 255, 255, 0.8);
    }

    @keyframes symbolSpin {
      0% { 
        transform: translateY(0) scale(0.9); 
        opacity: 0.3; 
      }
      50% { 
        opacity: 1; 
        transform: translateY(-140px) scale(1);
      }
      100% { 
        transform: translateY(-280px) scale(0.9); 
        opacity: 0.3; 
      }
    }

    .reel.spinning .symbol:nth-child(1) { 
      animation-delay: 0s; 
      animation-duration: 0.12s;
    }
    .reel.spinning .symbol:nth-child(2) { 
      animation-delay: 0.04s; 
      animation-duration: 0.11s;
    }
    .reel.spinning .symbol:nth-child(3) { 
      animation-delay: 0.08s; 
      animation-duration: 0.13s;
    }

    .win-line {
      position: absolute;
      top: 50%;
      left: -10px;
      right: -10px;
      height: 100px;
      transform: translateY(-50%);
      border: 2px solid var(--neon-green);
      background: rgba(0, 255, 115, 0.05);
      box-shadow: 0 0 30px rgba(0, 255, 115, 0.2);
      border-radius: 16px;
      pointer-events: none;
      z-index: 5;
    }

    /* --- SIDEBAR WIDGETS --- */
    .sidebar { display: flex; flex-direction: column; gap: 15px; }

    .widget {
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .widget-header {
      padding: 12px 18px;
      background: rgba(255,255,255,0.03);
      font-size: 10px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text-muted);
      border-bottom: 1px solid rgba(255,255,255,0.03);
      display: flex;
      justify-content: space-between;
    }

    .widget-body { padding: 15px; font-size: 13px; overflow: visible; flex: 1; word-wrap: break-word; }

    .item-row { margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.02); word-wrap: break-word; overflow-wrap: break-word; display: flex; align-items: center; gap: 8px; }
    .item-row .avatar { width: 24px; height: 24px; border-radius: 50%; object-fit: cover; flex-shrink: 0; border: 1px solid rgba(255,255,255,0.1); }
    .item-row .content { flex: 1; min-width: 0; }
    .user { color: var(--neon-green); font-weight: 700; }
    .msg { color: #bbb; display: block; margin-top: 2px; word-wrap: break-word; overflow-wrap: break-word; }
    .ts { float: right; color: #333; font-size: 10px; }

    /* --- FOOTER & DISCLAIMER --- */
    .hud-footer {
      grid-column: 1 / -1;
      padding: 0;
      position: relative;
      overflow: visible;
      display: flex !important;
      flex-direction: column;
      width: 100%;
      visibility: visible !important;
      opacity: 1 !important;
      z-index: 100;
    }

    .rules-header {
      background: transparent;
      backdrop-filter: none;
      border-top: none;
      padding: 20px 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      position: relative;
      z-index: 9999;
      overflow: hidden;
    }

    .rules-header::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(0, 210, 255, 0.15) 25%,
        rgba(255, 41, 117, 0.15) 50%,
        rgba(0, 210, 255, 0.15) 75%,
        transparent 100%
      );
      background-size: 200% 100%;
      animation: gradientShift 4s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .rules-header::after {
      content: '';
      position: absolute;
      inset: 0;
      box-shadow: 
        inset 0 0 60px rgba(0, 210, 255, 0.2),
        inset 0 0 100px rgba(255, 41, 117, 0.15),
        0 0 40px rgba(0, 210, 255, 0.3),
        0 0 80px rgba(255, 41, 117, 0.2);
      animation: glowPulse 3s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes glowPulse {
      0%, 100% { 
        box-shadow: 
          inset 0 0 60px rgba(0, 210, 255, 0.2),
          inset 0 0 100px rgba(255, 41, 117, 0.15),
          0 0 40px rgba(0, 210, 255, 0.3),
          0 0 80px rgba(255, 41, 117, 0.2);
      }
      50% { 
        box-shadow: 
          inset 0 0 80px rgba(0, 210, 255, 0.3),
          inset 0 0 120px rgba(255, 41, 117, 0.25),
          0 0 60px rgba(0, 210, 255, 0.4),
          0 0 100px rgba(255, 41, 117, 0.3);
      }
    }

    .rules-title-card {
      display: flex;
      align-items: center;
      gap: 20px;
      position: relative;
      z-index: 2;
    }

    .rules-title-icon {
      font-size: 48px;
      line-height: 1;
      filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.6)) drop-shadow(0 0 30px rgba(255, 41, 117, 0.4));
      animation: titlePulse 2s ease-in-out infinite;
      text-shadow: 0 0 20px currentColor;
    }

    @keyframes titlePulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.6)) drop-shadow(0 0 30px rgba(255, 41, 117, 0.4)); }
      50% { transform: scale(1.1); filter: drop-shadow(0 0 25px rgba(0, 210, 255, 0.8)) drop-shadow(0 0 40px rgba(255, 41, 117, 0.6)); }
    }

    .rules-title-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .rules-title-main {
      font-size: 24px;
      font-weight: 900;
      background: linear-gradient(90deg, 
        rgba(0, 210, 255, 1) 0%, 
        rgba(255, 41, 117, 1) 50%, 
        rgba(0, 210, 255, 1) 100%);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: 3px;
      text-transform: uppercase;
      text-shadow: 
        0 0 20px rgba(0, 210, 255, 0.5),
        0 0 40px rgba(255, 41, 117, 0.3);
      font-family: 'Montserrat', sans-serif;
      animation: textGradientShift 3s ease-in-out infinite;
      filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.5)) drop-shadow(0 0 25px rgba(255, 41, 117, 0.3));
    }

    @keyframes textGradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .rules-title-sub {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.7);
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .rules-ticker {
      background: transparent;
      backdrop-filter: none;
      border-top: none;
      border-radius: 0;
      padding: 28px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      min-height: 110px;
      width: 100%;
    }

    .rules-ticker::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 300px;
      background: linear-gradient(90deg, var(--bg-dark) 0%, transparent 100%);
      z-index: 3;
      pointer-events: none;
    }

    .rules-ticker::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 300px;
      background: linear-gradient(270deg, var(--bg-dark) 0%, transparent 100%);
      z-index: 3;
      pointer-events: none;
    }

    .rules-content {
      display: flex;
      align-items: center;
      gap: 50px;
      animation: scrollRules 80s linear infinite;
      white-space: nowrap;
      padding: 0 60px;
    }

    @keyframes scrollRules {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .rules-content:hover {
      animation-play-state: paused;
    }

    .rule-item {
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 16px 32px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
      border-radius: 18px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      font-size: 15px;
      color: var(--text-main);
      white-space: nowrap;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      min-height: 70px;
    }

    .rule-item:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.05) 100%);
      border-color: rgba(255, 255, 255, 0.2);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
    }

    .rule-item .icon {
      font-size: 28px;
      line-height: 1;
    }

    .rule-item .prize-icon {
      font-size: 36px;
      font-weight: 900;
      text-shadow: 0 0 15px currentColor;
      line-height: 1;
    }

    .rule-item .prize-icon.jackpot { color: var(--neon-pink); }
    .rule-item .prize-icon.points { color: var(--neon-green); }
    .rule-item .prize-icon.nft { color: var(--neon-blue); }
    .rule-item .prize-icon.extra { color: var(--gold); }

    .rule-item .text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .rule-item .main-text {
      font-weight: 800;
      color: #fff;
      font-size: 16px;
      letter-spacing: 0.5px;
    }

    .rule-item .sub-text {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .rule-separator {
      width: 3px;
      height: 50px;
      background: linear-gradient(180deg, transparent, var(--glass-border), transparent);
      opacity: 0.4;
    }

    .disclaimer {
      font-size: 11px;
      color: #777;
      max-width: 100%;
      margin: 0;
      line-height: 1.8;
      padding: 20px 30px;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(7, 8, 10, 0.98) 0%, rgba(5, 6, 8, 1) 100%);
      backdrop-filter: blur(10px);
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      width: 100%;
      box-sizing: border-box;
    }

    .disclaimer b {
      color: #aaa;
      font-weight: 700;
    }

    /* --- COMPATIBILITY TOPBAR (MODES 0, 1, 2) --- */
    .topbar {
      position: absolute; left: 24px; right: 24px; top: 18px;
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 20px;
      border: 1px solid var(--glass-border);
      background: var(--panel-bg);
      border-radius: 18px;
      z-index: 2000;
      backdrop-filter: blur(10px);
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .logo img { width: 40px; height: 40px; border-radius: 10px; }
    .pill { font-size: 13px; color: var(--text-muted); }
    .pill strong { color: #fff; }

    /* Helper Classes */
    .hidden { display: none !important; }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-thumb { background: #222; border-radius: 10px; }
  </style>
</head>
<body>

  <!-- AUDIO ELEMENTS -->
  <audio id="slotSfxIntro" preload="auto"><source src="audio/slotSfxIntro.wav" type="audio/wav"></audio>
  <audio id="slotSfxSpin" preload="auto"><source src="audio/slotSfxSpin.MP3" type="audio/mpeg"></audio>
  <audio id="slotSfxNext" preload="auto"><source src="audio/slotSfxNext.wav" type="audio/wav"></audio>
  <audio id="bgm" preload="auto" loop><source src="audio/bgm.mp3" type="audio/mpeg"></audio>

  <canvas class="gardenCanvas" id="gardenCanvas"></canvas>

  <!-- ELITE HUD (MODE 3) -->
  <div class="hudContainer" id="hudContainer">
    <!-- SLOT AREA -->
    <main class="slotMachineHud">
      <header class="slot-header">
        <div class="casino-brand">MEWVOLT CASINO</div>
        <div class="jackpot-pill" id="slotJackpot">JACKPOT: 0.25 SOL</div>
        <div style="font-size: 11px; color: var(--neon-green);" id="slotLive">LIVE 00:00:00</div>
      </header>

      <div class="slot-body">
        <div class="status-box">
          <p style="font-size: 10px; color: #555; margin-bottom: 5px; font-weight: 900;">SYSTEM READY</p>
          Type <span>/start</span> in chat to join
      </div>

        <div id="slotRulesBreak" class="hidden" style="text-align:center; max-width: 500px;">
          <h3 id="slotRulesTitle" style="color:var(--gold)">Rules</h3>
          <p id="slotRulesText" style="font-size: 18px;"></p>
          <p id="slotRulesDetail" style="color:#555; font-size: 12px; margin-top:10px;"></p>
      </div>

        <div class="reels-container" id="slotGrid">
          <div class="win-line"></div>
          
          <div class="reel">
            <div class="symbol points active">10</div>
            <div class="symbol jackpot active">7</div>
            <div class="symbol empty">â€”</div>
      </div>
          <div class="reel">
            <div class="symbol extra">SPIN</div>
            <div class="symbol nft active">NFT</div>
            <div class="symbol points">25</div>
      </div>
          <div class="reel">
            <div class="symbol jackpot active">7</div>
            <div class="symbol empty">â€”</div>
            <div class="symbol points">50</div>
    </div>
    </div>

        <h2 style="margin-top: 40px; font-weight: 900; letter-spacing: 5px; color: rgba(255,255,255,0.05)" id="slotWaiting">WAITING FOR BETS</h2>
      </div>

      <div style="padding: 10px; text-align: center; background: rgba(0,0,0,0.2); font-size: 11px; color: #444;" id="slotDateTime">00/00/0000 00:00:00</div>
    </main>

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <!-- LOGS -->
      <div class="widget" style="height: 220px;">
        <div class="widget-header">
          <span>Activity Logs</span>
          <span id="slotQueue" style="color:var(--neon-blue)">Q: 0</span>
    </div>
        <div class="widget-body" id="logsList"></div>
    </div>

      <!-- WINNERS -->
      <div class="widget" style="height: 180px;">
        <div class="widget-header">Recent Winners</div>
        <div class="widget-body" id="winnersList"></div>
    </div>

      <!-- CHAT -->
      <div class="widget" style="flex: 1;">
        <div class="widget-header">Community Chat</div>
        <div class="widget-body" id="chatMessages" style="display:flex; flex-direction:column-reverse;"></div>
      </div>
    </aside>

    <footer class="hud-footer">
      <div class="rules-header">
        <div class="rules-title-card">
          <span class="rules-title-icon">ðŸŽ°</span>
          <div class="rules-title-text">
            <span class="rules-title-main">RULES / REWARDS</span>
            <span class="rules-title-sub">Game Information</span>
          </div>
        </div>
      </div>
      <div class="rules-ticker">
        <div class="rules-content" id="rulesContent">
          <!-- Rules will be populated by JavaScript -->
        </div>
      </div>
      <p class="disclaimer">
        <b>RISK WARNING:</b> $MewVolt is a digital memecoin for entertainment purposes only. It has no intrinsic value. 
        Crypto markets are highly volatile. You may lose your entire investment. 
        This is a gaming simulation and not financial advice. <b>Always Do Your Own Research (DYOR) before investing in $MewVolt.</b>
      </p>
    </footer>
    </div>

  <!-- FALLBACK TOPBAR (MODE 0,1,2) -->
  <div class="topbar" id="oldTopbar">
    <div class="brand">
      <div class="logo"><img src="https://mewvolt.online/logo.png" alt="MeVolt" /></div>
      <div class="btext"><strong>MeVolt</strong> <span style="font-size:10px; color:#555;">Dev</span></div>
      </div>
    <div class="pill">Price: <strong id="priceVal">â€”</strong> SOL</div>
    <div class="pill">MCap: <strong id="marketCap">â€”</strong></div>
    <div class="pill">Holders: <strong id="holders">â€”</strong></div>
      </div>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

  <script>
    // --- USER CONFIG & STATE ---
    const CONFIG = {
      contract: 'CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump',
      pumpUrl: 'https://pump.fun/coin/CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump',
      wsUrl: 'wss://pumpportal.fun/api/data',
      chatWsUrl: 'https://livechat.pump.fun',
      corsProxies: ['https://corsproxy.io/?', 'https://api.allorigins.win/raw?url='],
      minBuyThreshold: 0.01
    };

    let coinData = { viewers: null, marketCap: null, holders: null, price: null };
    let slotState = { 
      queue: [], 
      jackpot: 1000, 
      userPoints: {}, 
      winners: [], 
      lastResetDate: new Date().toDateString(),
      dailySpins: {}, // Tracking spins per wallet per day
      dailyNFTCount: 0, // Global daily NFT count
      dailyPurchasesSOL: 0, // SOL purchases today
      yesterdayPurchasesSOL: 0 // SOL purchases yesterday (for jackpot calculation)
    };
    let processedTxSignatures = new Set();
    let chatEntries = [];
    let logEntries = [];
    let winnersEntries = [];
    let slotCurrent = null;

    // --- MODE DETECTION ---
    const urlParams = new URLSearchParams(window.location.search);
    const pageId = urlParams.get('id') || '3';

    // --- INITIALIZATION ---
    function init() {
      // Start background music
      const bgm = document.getElementById('bgm');
      if (bgm) {
        bgm.volume = 0.3; // Set volume to 30%
        bgm.play().catch(e => console.warn('[Audio] BGM play error (may require user interaction):', e));
      }

      // Toggle UI visibility
      if (pageId === '3') {
        document.getElementById('hudContainer').style.display = 'grid';
        document.getElementById('oldTopbar').classList.add('hidden');
        initThreeWorldMap(); // Start the 3D map
      } else {
        document.getElementById('hudContainer').classList.add('hidden');
        if (pageId === '0') initThreeGarden(); 
      }

      // Start Data Loops
      fetchAllCoinData();
      setInterval(fetchAllCoinData, 10000);
      
      // Slot System
      loadPersistentData().then(async () => {
        await checkDailyReset();
        await updateJackpot();
      });
      setInterval(updateSlotLiveTimer, 1000);
      setInterval(updateDateTime, 1000);
      setInterval(() => { checkDailyReset(); }, 60000); // Check daily reset every minute

      // Initialize rules ticker
      initRulesTicker();

      // Connections
      connectWS();
      connectChatWS();
    }

    // Initialize rules ticker in footer
    function initRulesTicker() {
      const rulesContent = document.getElementById('rulesContent');
      if (!rulesContent) return;

      const rules = [
        { icon: 'ðŸŽ°', main: 'JACKPOT', sub: '5% chance â€¢ MEWVOLT', class: 'jackpot' },
        { icon: 'ðŸ’Ž', main: '50 POINTS', sub: '5% chance', class: 'points' },
        { icon: 'ðŸŽ¨', main: 'FREE MINT NFT', sub: '10% chance â€¢ Max 2/day', class: 'nft' },
        { icon: 'â­', main: '25 POINTS', sub: '10% chance', class: 'points' },
        { icon: 'âœ¨', main: '10 POINTS', sub: '15% chance', class: 'points' },
        { icon: 'ðŸ”„', main: 'EXTRA SPIN', sub: '15% chance â€¢ Free play', class: 'extra' },
        { icon: 'ðŸ’¼', main: 'HOLDER', sub: '3 spins/day â€¢ â‰¥$5 MEWVOLT', class: 'points' },
        { icon: 'ðŸ‘¤', main: 'NON-HOLDER', sub: '1 spin/day', class: 'points' },
        { icon: 'ðŸ†', main: '1000 POINTS', sub: 'Reward: 1000 MEWVOLT', class: 'points' },
        { icon: 'ðŸ’°', main: 'JACKPOT ROLLOVER', sub: 'Accumulates if not won', class: 'jackpot' },
        { icon: 'ðŸŽ¯', main: 'COMMANDS', sub: '/start â€¢ /points', class: 'extra' },
        { icon: 'ðŸ“Š', main: 'NOTHING', sub: '40% chance', class: 'points' }
      ];

      // Duplicate rules for seamless loop
      const allRules = [...rules, ...rules];
      
      rulesContent.innerHTML = allRules.map((rule, idx) => {
        const separator = idx > 0 ? '<div class="rule-separator"></div>' : '';
        return `${separator}
          <div class="rule-item">
            <span class="prize-icon ${rule.class}">${rule.icon}</span>
            <div class="text">
              <span class="main-text">${rule.main}</span>
              <span class="sub-text">${rule.sub}</span>
            </div>
          </div>`;
      }).join('');
    }

    // --- DATA FETCHING (Pump.fun / DexScreener) ---
    async function fetchAllCoinData() {
      try {
        const dexUrl = `https://api.dexscreener.com/latest/dex/tokens/${CONFIG.contract}`;
        const res = await fetch(dexUrl);
        const data = await res.json();
        if (data.pairs && data.pairs[0]) {
          const p = data.pairs[0];
          document.getElementById('priceVal').textContent = parseFloat(p.priceNative).toFixed(8);
          document.getElementById('marketCap').textContent = '$' + (p.marketCap / 1000000).toFixed(2) + 'M';
          // Sync with Elite HUD
          if (pageId === '3') {
            document.getElementById('slotJackpot').textContent = `JACKPOT: ${slotState.jackpot.toFixed(0)} MEWVOLT`;
          }
        }
      } catch (e) { console.log("Data fetch error", e); }
    }

    // --- WEBSOCKETS (Trades & Chat) ---
    function connectWS() {
      const ws = new WebSocket(CONFIG.wsUrl);
      ws.onopen = () => ws.send(JSON.stringify({ method: 'subscribeTokenTrade', keys: [CONFIG.contract] }));
      ws.onmessage = (e) => {
        const data = JSON.parse(e.data);
        if (data.txType === 'buy') {
          handleBuy(data.traderPublicKey, data.solAmount);
        }
      };
      ws.onclose = () => setTimeout(connectWS, 3000);
    }

    function handleBuy(wallet, sol) {
      if (sol >= CONFIG.minBuyThreshold) {
        addLog(`ðŸ’° New Buy! ${wallet.slice(0,4)}... paid ${sol.toFixed(2)} SOL`, '#00ff73');
        // 4. Track purchases for jackpot calculation
        slotState.dailyPurchasesSOL = (slotState.dailyPurchasesSOL || 0) + sol;
        saveSlotState(); // Persist state
      }
    }

    function connectChatWS() {
      // Preferred: use local SSE proxy (avoids browser CORS/auth issues with livechat.pump.fun)
      if (typeof EventSource !== 'undefined') {
        // Use commands=1 to get command events directly from server
        const sseUrl = `/chat-sse?room=${encodeURIComponent(CONFIG.contract)}&commands=1`;
        console.log('[Chat] Connecting via SSE:', sseUrl);

        try {
          const es = new EventSource(sseUrl);

          es.onopen = () => {
            console.log('[Chat] SSE connected');
          };

          es.onerror = (err) => {
            console.warn('[Chat] SSE error (will retry automatically):', err);
          };

          es.onmessage = (ev) => {
            try {
              const msg = JSON.parse(ev.data);
              console.log('[Chat] SSE onmessage received:', msg);
              // Server sends: { event: 'newMessage', data: {...} }
              if (msg && msg.data) {
                processChatMessage(msg);
              } else if (msg && !msg.event) {
                // Direct message data without envelope
                processChatMessage(msg);
              }
            } catch (e) {
              console.warn('[Chat] SSE parse error:', e, ev.data);
            }
          };

          // Listen for specific SSE events (newMessage, command, etc.)
          es.addEventListener('newMessage', (ev) => {
            try {
              const payload = JSON.parse(ev.data);
              // Payload can be direct message data or wrapped in { event, data }
              if (payload && payload.data) {
                processChatMessage(payload);
              } else {
                processChatMessage({ event: 'newMessage', data: payload });
              }
            } catch (e) {
              console.warn('[Chat] SSE newMessage parse error:', e);
            }
          });

          es.addEventListener('command', (ev) => {
            try {
              const cmd = JSON.parse(ev.data);
              console.log('[Chat] SSE command event received:', cmd);
              
              // Server sends: { cmd, text, userAddress, username, ... }
              const text = cmd.text || (cmd.cmd ? `/${cmd.cmd}` : '');
              const wallet = cmd.userAddress || cmd.wallet || null;
              const username = cmd.username || cmd.user || 'User';
              
              if (text) {
                console.log('[Chat] Processing command from SSE:', { text, username, wallet });
                processChatCommand(text, username, { wallet, userAddress: wallet, ...cmd });
              } else {
                console.warn('[Chat] SSE command missing text:', cmd);
              }
            } catch (e) {
              console.warn('[Chat] SSE command parse error:', e, ev.data);
            }
          });

          es.addEventListener('message', (ev) => {
            try {
              const payload = JSON.parse(ev.data);
              if (payload && payload.data) {
                processChatMessage(payload);
                } else {
                processChatMessage({ event: 'message', data: payload });
              }
            } catch (e) {
              console.warn('[Chat] SSE message parse error:', e);
            }
          });

          // Listen for other message-related events
          ['chat_message', 'new_message', 'msg', 'room_message', 'chat'].forEach(eventName => {
            es.addEventListener(eventName, (ev) => {
              try {
                const payload = JSON.parse(ev.data);
                if (payload && payload.data) {
                  processChatMessage(payload);
          } else {
                  processChatMessage({ event: eventName, data: payload });
                }
              } catch (e) {
                console.warn(`[Chat] SSE ${eventName} parse error:`, e);
              }
            });
          });

          window.addEventListener('beforeunload', () => {
            try { es.close(); } catch {}
          });

          return;
        } catch (e) {
          console.warn('[Chat] SSE init failed, falling back to Socket.IO:', e);
        }
      }

      // Fallback: direct Socket.IO (may fail due to CORS/auth)
        if (typeof io === 'undefined') {
        console.warn('[Chat] Socket.IO not loaded');
          return;
        }

      console.log('[Chat] Connecting to', CONFIG.chatWsUrl);
      const socket = io(CONFIG.chatWsUrl, {
        transports: ['websocket', 'polling'],
          reconnection: true,
        reconnectionDelay: 2000
      });

      socket.on('connect', () => {
        console.log('[Chat] Connected, joining room:', CONFIG.contract);
        socket.emit('join_room', CONFIG.contract);
        socket.emit('joinRoom', { roomId: CONFIG.contract, username: 'overlay' }, (ack) => {
          console.log('[Chat] joinRoom ack:', ack);
        });
        socket.emit('subscribe', { room: CONFIG.contract });
      });

      socket.on('disconnect', () => {
        console.log('[Chat] Disconnected');
      });

      socket.on('connect_error', (err) => {
        console.error('[Chat] Connection error:', err);
      });

      socket.on('newMessage', (data) => {
        console.log('[Chat] Received newMessage event:', data);
        processChatMessage(data);
      });

      socket.onAny((eventName, ...args) => {
        const ev = String(eventName || '').toLowerCase();
        if (ev.includes('message') || ev.includes('chat')) {
          console.log('[Chat] Event:', eventName, args);
          if (args[0]) processChatMessage(args[0]);
        }
      });
    }

    function processChatMessage(data) {
      // Handle different data formats
      let user, text, wallet;

      // Unwrap SSE envelope: { event, data }
      if (data && typeof data === 'object' && data.data && (data.event || data.type)) {
        data = data.data;
      }
      
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
      } catch {
          text = data;
          user = "User";
        }
      }
      
      user = data.user || data.username || data.name || "User";
      text = data.text || data.message || data.msg || data.content || "";
      wallet = data.wallet || data.userAddress || data.address || null;

      // Normalize text payloads (Pump.fun often sends { message: string|array })
      if (Array.isArray(text)) {
        text = String(text[0] || '');
      } else if (typeof text !== 'string') {
        text = text == null ? '' : String(text);
      }
      
      if (!text || !text.trim()) {
        console.log('[Chat] Skipping empty message:', data);
            return;
          }

      console.log('[Chat] Processing message:', { user, text: text.substring(0, 50), wallet });

      // Check for duplicates (same user + message within last 2 seconds)
      const now = Date.now();
      const isDuplicate = chatEntries.some(e => 
        e.username === user && e.message === text && Math.abs(e.timestamp - now) < 2000
      );
      if (isDuplicate) {
        console.log('[Chat] Skipping duplicate message');
        return;
      }

      const avatarUrl = data.avatarUrl || data.profile_image || '';
      const chatEntry = { username: user, message: text, timestamp: now, avatarUrl };
      chatEntries.push(chatEntry);
      if (chatEntries.length > 50) chatEntries.shift();
      updateChatHud();

      // Save to drive_db
      saveToDriveDb({
        chats: [{
          ts: Date.now(),
          id: data.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          username: user,
          avatarUrl: data.avatarUrl || data.profile_image || '',
          text: text,
          userAddress: wallet
        }]
      });

      // Process chat commands (if message starts with /)
      if (text.trim().startsWith('/')) {
        console.log('[Chat] Detected command in message:', text);
        processChatCommand(text, user, { ...data, wallet });
      }
    }
    
    function processChatCommand(text, user, data) {
      if (!text || typeof text !== 'string') {
        console.warn('[Command] Invalid text:', text);
        return;
      }
      
      const cmd = text.toLowerCase().trim();
      console.log('[Command] Processing:', { cmd, user, wallet: data.wallet || data.userAddress });
      
      // Support /start and /spin commands
      if (cmd === '/start' || cmd.startsWith('/start ') || cmd === '/spin' || cmd.startsWith('/spin ')) {
        const wallet = data.wallet || data.userAddress || "unknown";
        console.log('[Command] /start or /spin detected, adding to queue:', { user, wallet });
        addToQueue(user, wallet);
      } else if (cmd === '/points') {
        const wallet = data.wallet || data.userAddress || null;
        if (wallet && wallet !== 'unknown') {
          const points = slotState.userPoints[wallet] || 0;
          const remaining = Math.max(0, 1000 - points);
          addLog(`ðŸ“Š ${user} has ${points} points (${remaining} to 1000)`, '#00d2ff');
      } else {
          addLog(`âš ï¸ ${user} has no wallet address`, '#ff8800');
        }
            } else {
        console.log('[Command] Unknown command:', cmd);
      }
    }

    // --- SLOT MACHINE LOGIC ---
    const SLOT_CONFIG = {
      PRIZES: [
        { name: 'Nothing', prob: 0.40 },
        { name: 'Extra spin', prob: 0.15 },
        { name: '10 points', prob: 0.15 },
        { name: '25 points', prob: 0.10 },
        { name: 'Free Mint NFT', prob: 0.10 },
        { name: 'Jackpot', prob: 0.05 },
        { name: '50 points', prob: 0.05 }
      ],
      POINTS_REWARD_MEWVOLT: 1000,
      NFT_DAILY_LIMIT: 2
    };

    async function processQueue() {
      if (slotState.queue.length === 0) return;
      
      const player = slotState.queue.shift();
      
      // Play intro sound when player starts
      const introAudio = document.getElementById('slotSfxIntro');
      if (introAudio) {
        introAudio.currentTime = 0;
        introAudio.play().catch(e => console.warn('[Audio] Intro sound error:', e));
      }
      
      slotCurrent = { ...player, phase: 'spinning' };
      updateSlotMachineHud();
      
      // 7. Increment daily spins counter
      const spinKey = (player.wallet && player.wallet !== 'unknown')
        ? player.wallet
        : `unknown:${String(player.username || 'user').toLowerCase()}`;
      if (player.kind !== 'bonus') {
        slotState.dailySpins[spinKey] = (slotState.dailySpins[spinKey] || 0) + 1;
        saveSlotState(); // Persist state
      }
      
      // Animate reels spinning
      spinReels();
      
      // Wait for spin animation
      await new Promise(r => setTimeout(r, 3000));
      
      // Select prize and stop reels (pass isHolder status for different probabilities)
      const prize = selectPrize(player.isHolder || false);
      stopReels(prize);
      
      slotCurrent.phase = 'result';
      slotCurrent.result = prize;
      
      // Process prize
      await processPrize(player.wallet, player.username, prize);
      
      updateSlotMachineHud();

            setTimeout(() => {
        slotCurrent = null;
        updateSlotMachineHud();
        processQueue();
      }, 3000);
    }

    function selectPrize(isHolder = true) {
      // Different probabilities for non-holders
      if (!isHolder) {
        const r = Math.random();
        if (r <= 0.50) {
          return 'Nothing'; // 50%
        } else if (r <= 0.85) {
          return '10 points'; // 35%
        } else {
          return '25 points'; // 15%
        }
      }
      
      // Original probabilities for holders
      const r = Math.random();
      let cumulative = 0;
      
      for (const prize of SLOT_CONFIG.PRIZES) {
        cumulative += prize.prob;
        if (r <= cumulative) {
          // Check NFT limit
          if (prize.name === 'Free Mint NFT') {
            const nftCount = (slotState.dailyNFTCount || 0);
            if (nftCount >= SLOT_CONFIG.NFT_DAILY_LIMIT) {
              // Fallback to points
              return Math.random() < 0.5 ? '25 points' : '10 points';
            }
          }
          return prize.name;
        }
      }
      return 'Nothing';
    }

    function spinReels() {
      const reels = document.querySelectorAll('#slotGrid .reel');
      reels.forEach((reel, reelIdx) => {
        reel.classList.add('spinning');
        
        // Animate each reel with different delays for visual effect
        setTimeout(() => {
          const symbols = reel.querySelectorAll('.symbol');
          symbols.forEach((sym, symIdx) => {
            sym.style.animation = `symbolSpin ${0.1 + reelIdx * 0.05}s linear infinite`;
          });
        }, reelIdx * 100);
      });
    }

    function stopReels(prize) {
      // Stop spin sound
      const spinAudio = document.getElementById('slotSfxSpin');
      if (spinAudio) {
        spinAudio.pause();
        spinAudio.currentTime = 0;
      }

      const reels = document.querySelectorAll('#slotGrid .reel');
      
      // Stop each reel with staggered timing for better effect
      reels.forEach((reel, idx) => {
        setTimeout(() => {
          reel.classList.remove('spinning');
          
          const symbols = reel.querySelectorAll('.symbol');
          symbols.forEach((sym, symIdx) => {
            sym.style.animation = 'none';
            sym.classList.remove('active');
            
            // Set final symbols based on prize (middle symbol shows the prize)
            // Middle symbol (symIdx === 1) shows the prize, others are random
            if (symIdx === 1) {
              sym.classList.add('active');
              
              // Determine symbol based on prize (all matching GAME_RULES.md)
              if (prize === 'Jackpot') {
                sym.textContent = '7';
                sym.className = 'symbol jackpot active';
              } else if (prize === '50 points') {
                sym.textContent = '50';
                sym.className = 'symbol points active';
              } else if (prize === '25 points') {
                sym.textContent = '25';
                sym.className = 'symbol points active';
              } else if (prize === '10 points') {
                sym.textContent = '10';
                sym.className = 'symbol points active';
              } else if (prize === 'Free Mint NFT') {
                sym.textContent = 'NFT';
                sym.className = 'symbol nft active';
              } else if (prize === 'Extra spin') {
                sym.textContent = 'SPIN';
                sym.className = 'symbol extra active';
      } else {
                // Nothing (40%)
                sym.textContent = 'â€”';
                sym.className = 'symbol empty active';
              }
        } else {
              // Fill other positions with random symbols from available prizes
              const allSymbols = [
                { text: '10', class: 'points' },
                { text: '25', class: 'points' },
                { text: '50', class: 'points' },
                { text: 'NFT', class: 'nft' },
                { text: 'SPIN', class: 'extra' },
                { text: '7', class: 'jackpot' },
                { text: 'â€”', class: 'empty' }
              ];
              const randomSym = allSymbols[Math.floor(Math.random() * allSymbols.length)];
              sym.textContent = randomSym.text;
              sym.className = `symbol ${randomSym.class}`;
            }
          });

          // Play stop sound on last reel
          if (idx === reels.length - 1) {
            const nextAudio = document.getElementById('slotSfxNext');
            if (nextAudio) {
              nextAudio.currentTime = 0;
              nextAudio.play().catch(e => console.warn('[Audio] Next sound error:', e));
            }
          }
        }, idx * 200);
      });
    }

    async function processPrize(wallet, username, prize) {
      if (prize === 'Nothing') {
        addLog(`ðŸ˜” ${username} got nothing`, '#666');
        return;
      }
      
      if (prize === 'Extra spin') {
        slotState.queue.unshift({ username, wallet, kind: 'bonus' });
        addLog(`ðŸ”„ ${username} got extra spin!`, '#00d2ff');
        return;
      }
      
      if (prize.includes('points')) {
        const points = parseInt(prize.match(/\d+/)?.[0] || '0');
        if (points > 0) {
          if (!wallet || wallet === 'unknown') {
            addLog(`âš ï¸ ${username} has no wallet address (points not credited)`, '#ff8800');
        return;
      }

          slotState.userPoints[wallet] = (slotState.userPoints[wallet] || 0) + points;
          addLog(`ðŸŽ ${username} won ${points} points!`, '#00ff73');
          addWinner(username, `${points} points`, points);
          saveSlotState();
          
          // Check for 1000 points milestone
          if (slotState.userPoints[wallet] >= 1000) {
            addLog(`ðŸ† ${username} reached 1000 points!`, '#ffcc00');
            // 5. Trigger payout for 1000 points
            payoutPoints(wallet, username);
            slotState.userPoints[wallet] = slotState.userPoints[wallet] - 1000;
            saveSlotState();
          }
        }
        return;
      }
      
      if (prize === 'Free Mint NFT') {
        slotState.dailyNFTCount = (slotState.dailyNFTCount || 0) + 1;
        addLog(`ðŸŽ¨ ${username} won Free Mint NFT!`, '#ff2975');
        addWinner(username, prize);
        saveSlotState();
        return;
      }
      
      if (prize === 'Jackpot') {
        addLog(`ðŸŽ° ${username} WON THE JACKPOT! ${slotState.jackpot} MEWVOLT`, '#ffcc00');
        addWinner(username, `JACKPOT ${slotState.jackpot} MEWVOLT`, slotState.jackpot);
        // 5. Trigger jackpot payout
        payoutJackpot(wallet, username);
        // Reset pot after win; rollover happens when not won
        slotState.jackpot = SLOT_CONFIG.POINTS_REWARD_MEWVOLT;
        updateJackpot();
        saveSlotState();
        return;
      }
      
      addWinner(username, prize);
    }

    // --- UI UPDATES ---
    function updateChatHud() {
      const container = document.getElementById('chatMessages');
      if (!container) return;
      // Remove duplicates based on username + message + timestamp (within 2 seconds)
      const uniqueEntries = [];
      const seen = new Set();
      for (const e of chatEntries.slice(-15).reverse()) {
        const key = `${e.username}:${e.message}:${Math.floor(e.timestamp / 2000)}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniqueEntries.push(e);
        }
      }
      container.innerHTML = uniqueEntries.reverse().map(e => {
        const avatarImg = e.avatarUrl ? `<img src="${e.avatarUrl}" alt="${e.username}" class="avatar" onerror="this.style.display='none'">` : '<div class="avatar" style="background: rgba(255,255,255,0.1);"></div>';
        return `
        <div class="item-row">
          ${avatarImg}
          <div class="content">
            <span class="ts">${new Date(e.timestamp).toLocaleTimeString()}</span>
            <span class="user">${e.username}:</span>
            <span class="msg">${e.message}</span>
          </div>
        </div>
      `;
      }).join('');
    }

    function addLog(text, color, meta = {}) {
      // Check for duplicates (same text within last 5 seconds)
      const now = Date.now();
      const isDuplicate = logEntries.some(e => 
        e.text === text && Math.abs(e.ts - now) < 5000
      );
      if (isDuplicate) {
        return; // Skip duplicate
      }
      
      // Save to drive_db
      const levelFromColor = (c) => {
        if (!c) return 'info';
        const v = String(c).toLowerCase();
        if (v === '#00ff73') return 'success';
        if (v === '#ff8800') return 'warn';
        if (v === '#ff4444') return 'error';
        if (v === '#ffcc00') return 'special';
        return 'info';
      };
      const logEntry = {
        ts: now,
        username: meta.username || null,
        text: text,
        action: meta.action || null,
        userAddress: meta.userAddress || null,
        avatarUrl: meta.avatarUrl || null,
        level: meta.level || levelFromColor(color)
      };
      logEntries.unshift(logEntry); // Add to start
      if (logEntries.length > 20) logEntries.pop(); // Remove from end
      
      // Update UI from array (prevents duplicates)
      updateLogsHud();
      
      saveToDriveDb({ logs: [logEntry] });
    }

    function updateLogsHud() {
      const container = document.getElementById('logsList');
      if (!container) return;
      container.innerHTML = logEntries.map(e => {
        const text = e.text || e.action || JSON.stringify(e);
        const level = e.level || 'info';
        const color = level === 'success' ? '#00ff73'
          : level === 'warn' ? '#ff8800'
          : level === 'error' ? '#ff4444'
          : level === 'special' ? '#ffcc00'
          : '#ccc';
        const avatarImg = e.avatarUrl ? `<img src="${e.avatarUrl}" alt="${e.username || ''}" class="avatar" onerror="this.style.display='none'">` : '<div class="avatar" style="background: rgba(255,255,255,0.1);"></div>';
        return `<div class="item-row" style="color:${color}">
          ${avatarImg}
          <div class="content">
            <span class="ts">${new Date(e.ts || Date.now()).toLocaleTimeString()}</span> ${text}
          </div>
        </div>`;
      }).join('');
    }

    function addWinner(user, prize, amount = null, avatarUrl = null) {
      // Check for duplicates (same user + prize within last 5 seconds)
      const now = Date.now();
      const isDuplicate = winnersEntries.some(e => 
        e.username === user && e.prize === prize && Math.abs(e.ts - now) < 5000
      );
      if (isDuplicate) {
        return; // Skip duplicate
      }
      
      // Save to drive_db
      const winnerEntry = {
        ts: now,
        username: user,
        prize: prize,
        amount: amount,
        avatarUrl: avatarUrl
      };
      winnersEntries.unshift(winnerEntry); // Add to start
      if (winnersEntries.length > 10) winnersEntries.pop(); // Remove from end
      
      // Update UI from array (prevents duplicates)
      updateWinnersHud();
      
      saveToDriveDb({ winners: [winnerEntry] });
    }

    function updateWinnersHud() {
      const container = document.getElementById('winnersList');
      if (!container) return;
      container.innerHTML = winnersEntries.map(e => {
        const prize = e.prize || e.action || 'PRIZE';
        const avatarImg = e.avatarUrl ? `<img src="${e.avatarUrl}" alt="${e.username || ''}" class="avatar" onerror="this.style.display='none'">` : '<div class="avatar" style="background: rgba(255,255,255,0.1);"></div>';
        return `<div class="item-row">
          ${avatarImg}
          <div class="content">
            <span class="user">${e.username || 'Unknown'}</span> won 
            <span style="color:var(--gold)">${prize}</span>
          </div>
        </div>`;
      }).join('');
    }

    function updateSlotMachineHud() {
      document.getElementById('slotQueue').textContent = `Q: ${slotState.queue.length}`;
      const status = document.getElementById('slotWaiting');
      if (slotCurrent) {
        status.textContent = slotCurrent.phase === 'spinning' ? 'ROLLING...' : `WINNER: ${slotCurrent.result}`;
        status.style.color = slotCurrent.phase === 'spinning' ? 'var(--gold)' : 'var(--neon-green)';
      } else {
        status.textContent = 'WAITING FOR BETS';
        status.style.color = 'rgba(255,255,255,0.05)';
      }
    }

    function updateSlotLiveTimer() {
      const el = document.getElementById('slotLive');
      const now = new Date();
      el.textContent = `LIVE ${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
    }

    function updateDateTime() {
      document.getElementById('slotDateTime').textContent = new Date().toLocaleString();
    }

    // --- DRIVE DB PERSISTENCE ---
    async function loadPersistentData() {
      try {
        const res = await fetch('/drive/read');
        if (!res.ok) {
          console.warn(`[Drive DB] Read endpoint returned ${res.status} - server may need restart`);
          return;
        }
        const text = await res.text();
        let result;
        try {
          result = JSON.parse(text);
        } catch (e) {
          console.warn('[Drive DB] Response is not JSON:', text.substring(0, 100));
          return;
        }
        if (result.ok && result.data) {
          // Load chats
          if (Array.isArray(result.data.chats)) {
            chatEntries = result.data.chats
              .map(c => ({
                username: c.username || 'Unknown',
                message: c.text || '',
                timestamp: c.ts || Date.now(),
                avatarUrl: c.avatarUrl || ''
              }))
              .filter(c => c.message)
              .slice(-50);
            updateChatHud();
          }
          
          // Load logs
          if (Array.isArray(result.data.logs)) {
            logEntries = result.data.logs.slice(-20).reverse(); // Reverse to get newest first
            updateLogsHud();
          }
          
          // Load winners
          if (Array.isArray(result.data.winners)) {
            winnersEntries = result.data.winners.slice(-10).reverse(); // Reverse to get newest first
            updateWinnersHud();
          }
          
          // 6. Load slotState from drive_db
          if (result.data.slotState) {
            const loadedSlotState = result.data.slotState;
            console.log('[Drive DB] Loading slotState:', loadedSlotState);
            
            Object.assign(slotState, {
              ...slotState,
              ...loadedSlotState,
              queue: [], // Don't restore queue on load
              lastResetDate: loadedSlotState.lastResetDate || new Date().toDateString(),
              dailySpins: loadedSlotState.dailySpins || {},
              userPoints: loadedSlotState.userPoints || {},
              jackpot: Number(loadedSlotState.jackpot) || 1000,
              dailyNFTCount: Number(loadedSlotState.dailyNFTCount) || 0,
              dailyPurchasesSOL: Number(loadedSlotState.dailyPurchasesSOL) || 0,
              yesterdayPurchasesSOL: Number(loadedSlotState.yesterdayPurchasesSOL) || 0
            });
            
            console.log('[Drive DB] SlotState loaded:', slotState);
            
            // Check if daily reset needed
            checkDailyReset();
          } else {
            console.warn('[Drive DB] No slotState found in drive_db.json, using defaults');
          }
          
          console.log('[Drive DB] Loaded:', { 
            chats: chatEntries.length, 
            logs: logEntries.length, 
            winners: winnersEntries.length,
            slotState: !!result.data.slotState,
            jackpot: slotState.jackpot,
            dailySpinsCount: Object.keys(slotState.dailySpins || {}).length,
            userPointsCount: Object.keys(slotState.userPoints || {}).length
          });
        }
      } catch (err) {
        console.error('[Drive DB] Load error:', err);
      }
    }

    // 6. Persist slotState to drive_db
    async function saveSlotState() {
      try {
        const stateToSave = {
          ...slotState,
          queue: [] // Don't persist queue
        };
        console.log('[SlotState] Saving to drive_db.json:', stateToSave);
        
        // Save via append (slotState is merged server-side)
        const res = await fetch('/drive/append', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ slotState: stateToSave })
        });
        
        const result = await res.json();
        if (result.ok) {
          console.log('[SlotState] Saved successfully to MeVoltOBS/drive_db.json');
        } else {
          console.error('[SlotState] Save failed:', result.error);
        }
      } catch (err) {
        console.error('[SlotState] Save error:', err);
      }
    }

    async function saveToDriveDb(data) {
      try {
        const res = await fetch('/drive/append', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        const result = await res.json();
        if (result.ok) {
          console.log('[Drive DB] Saved successfully to MeVoltOBS/drive_db.json:', Object.keys(data));
        } else {
          console.error('[Drive DB] Save failed:', result.error);
        }
      } catch (err) {
        console.error('[Drive DB] Save error:', err);
      }
    }

    // 2. Daily reset check and execution
    async function checkDailyReset() {
      const today = new Date().toDateString();
      if (slotState.lastResetDate !== today) {
        await resetDailySlotData();
      }
    }

    async function resetDailySlotData() {
      const today = new Date().toDateString();
      
      // 3. Calculate jackpot from yesterday's purchases
      slotState.yesterdayPurchasesSOL = slotState.dailyPurchasesSOL || 0;
      await applyDailyJackpotUpdate();
      
      // Reset daily counters
      slotState.dailySpins = {};
      slotState.dailyNFTCount = 0;
      slotState.dailyPurchasesSOL = 0;
      slotState.lastResetDate = today;
      
      saveSlotState();
      addLog(`[Daily Reset] Reset completed for ${today}`, '#ccc', { level: 'info' });
    }

    // 3. Update jackpot based on yesterday's purchases
    async function updateJackpot() {
      slotState.jackpot = Number(slotState.jackpot) || 0;
      // Minimum jackpot: 1000 MEWVOLT
      if (!slotState.jackpot || slotState.jackpot < 1000) {
        slotState.jackpot = SLOT_CONFIG.POINTS_REWARD_MEWVOLT;
      }
      
      // Update UI
      const jackpotEl = document.getElementById('slotJackpot');
      if (jackpotEl) {
        jackpotEl.textContent = `JACKPOT: ${slotState.jackpot.toFixed(0)} MEWVOLT`;
      }
      saveSlotState();
    }

    async function applyDailyJackpotUpdate() {
      const mewvoltPriceInSOL = await fetchMewvoltPriceInSOL();
      const jackpotInSOL = (slotState.yesterdayPurchasesSOL || 0) / 10;
      let contribution = 0;
      if (jackpotInSOL > 0 && mewvoltPriceInSOL > 0) {
        contribution = jackpotInSOL / mewvoltPriceInSOL;
      }

      if (!contribution || contribution <= 0) {
        contribution = 1000;
      }

      const current = Number(slotState.jackpot) || 0;
      slotState.jackpot = current + contribution;
      if (slotState.jackpot < 1000) slotState.jackpot = 1000;

      await updateJackpot();
    }

    async function fetchMewvoltPriceInSOL() {
      try {
        const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${CONFIG.contract}`);
        const data = await res.json();
        if (data.pairs && data.pairs[0]) {
          return parseFloat(data.pairs[0].priceNative) || 0;
        }
      } catch (e) {}
      return 0;
    }

    // 5. Payout functions
    async function payoutPoints(wallet, username) {
      if (!wallet || wallet === 'unknown') {
        addLog(`âš ï¸ Payout ignored: ${username} has no wallet address`, '#ff8800');
        return;
      }
      
      try {
        const tokenRes = await fetch('/payout-token');
        const tokenData = await tokenRes.json();
        const payoutToken = tokenData.token;
        
        if (!payoutToken) {
          addLog(`âš ï¸ Payout failed: PAYOUT_TOKEN not configured`, '#ff4444');
          return;
        }
        
        const payoutRes = await fetch('/payout', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'x-payout-token': payoutToken
          },
          body: JSON.stringify({
            kind: 'spl',
            toWallet: wallet,
            mint: CONFIG.contract,
            amountTokens: SLOT_CONFIG.POINTS_REWARD_MEWVOLT
          })
        });
        
        const result = await payoutRes.json();
        if (result.ok && result.sig) {
          addLog(`âœ… Payout sent: ${username} received ${SLOT_CONFIG.POINTS_REWARD_MEWVOLT} MEWVOLT`, '#00ff73');
          addLog(`ðŸ”— TX: https://solscan.io/tx/${result.sig}`, '#00d2ff');
        } else {
          addLog(`âŒ Payout failed: ${result.error || 'Unknown error'}`, '#ff4444');
        }
      } catch (err) {
        addLog(`âŒ Payout error: ${err.message}`, '#ff4444');
      }
    }

    async function payoutJackpot(wallet, username) {
      if (!wallet || wallet === 'unknown') {
        addLog(`âš ï¸ Payout ignored: ${username} has no wallet address`, '#ff8800');
        return;
      }
      
      try {
        const tokenRes = await fetch('/payout-token');
        const tokenData = await tokenRes.json();
        const payoutToken = tokenData.token;
        
        if (!payoutToken) {
          addLog(`âš ï¸ Jackpot payout failed: PAYOUT_TOKEN not configured`, '#ff4444');
          return;
        }
        
        const jackpotAmount = slotState.jackpot || SLOT_CONFIG.POINTS_REWARD_MEWVOLT;
        
        const payoutRes = await fetch('/payout', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'x-payout-token': payoutToken
          },
          body: JSON.stringify({
            kind: 'spl',
            toWallet: wallet,
            mint: CONFIG.contract,
            amountTokens: jackpotAmount
          })
        });
        
        const result = await payoutRes.json();
        if (result.ok && result.sig) {
          addLog(`âœ… Payout sent: ${username} received ${jackpotAmount} MEWVOLT`, '#00ff73');
          addLog(`ðŸ”— TX: https://solscan.io/tx/${result.sig}`, '#00d2ff');
        } else {
          addLog(`âŒ Jackpot payout failed: ${result.error || 'Unknown error'}`, '#ff4444');
        }
      } catch (err) {
        addLog(`âŒ Jackpot payout error: ${err.message}`, '#ff4444');
      }
    }

    // 1. Holder check and daily limits
    async function checkIsHolder(wallet) {
      if (!wallet || wallet === 'unknown') return false;
      try {
        const res = await fetch(`/holder-check?wallet=${encodeURIComponent(wallet)}`);
        const data = await res.json();
        return data.ok && data.isHolder === true;
      } catch (e) {
        return false;
      }
    }

    function getDailySpinLimit(isHolder) {
      return isHolder ? 3 : 1;
    }

    async function addToQueue(username, wallet) {
      console.log('[Queue] addToQueue called:', { username, wallet });
      
      // Check if already in queue
      const alreadyInQueue = slotState.queue.some(q => q.username === username || (wallet && wallet !== 'unknown' && q.wallet === wallet));
      if (alreadyInQueue) {
        console.log('[Queue] Already in queue:', username);
        return;
      }
      
      // Check daily reset
      await checkDailyReset();
      
      // 1. Check holder status (only if wallet is valid)
      let isHolder = false;
      if (wallet && wallet !== 'unknown') {
        try {
          isHolder = await checkIsHolder(wallet);
          console.log('[Queue] Holder check result:', { wallet, isHolder });
        } catch (e) {
          console.warn('[Queue] Holder check failed:', e);
        }
      }
      
      const limit = getDailySpinLimit(isHolder);
      const spinKey = (wallet && wallet !== 'unknown')
        ? wallet
        : `unknown:${String(username || 'user').toLowerCase()}`;
      const currentSpins = slotState.dailySpins[spinKey] || 0;
      
      console.log('[Queue] Spin limits:', { spinKey, currentSpins, limit, isHolder });
      
      // Check if user has reached daily limit
      if (currentSpins >= limit) {
        addLog(`âš ï¸ ${username} reached daily limit (${limit} spins/day)`, '#ff8800');
        return;
      }
      
      slotState.queue.push({ username, wallet: wallet || 'unknown', isHolder, kind: 'normal' });
      addLog(`ðŸŽŸï¸ ${username} joined the queue (${currentSpins + 1}/${limit} spins)`, '#00d2ff');
      updateSlotMachineHud();
      
      console.log('[Queue] Added to queue:', { username, wallet, queueLength: slotState.queue.length });
      
      if (!slotCurrent) {
        console.log('[Queue] Starting queue processing');
        processQueue();
      } else {
        console.log('[Queue] Queue processing already in progress');
      }
    }

    // --- THREE.JS WORLD MAP ---
    let threeScene, threeCamera, threeRenderer, threeAnimId;
    
    function initThreeWorldMap() {
      if (typeof THREE === 'undefined') {
        console.error('[Three.js] Library not loaded!');
        return;
      }
      
      const canvas = document.getElementById('gardenCanvas');
      if (!canvas) {
        console.error('[Three.js] Canvas not found!');
        return;
      }
      
      // Scene
      threeScene = new THREE.Scene();
      threeScene.background = new THREE.Color(0x07080a);
      
      // Camera
      const width = window.innerWidth;
      const height = window.innerHeight;
      threeCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
      threeCamera.position.set(0, 5, 10);
      threeCamera.lookAt(0, 0, 0);
      
      // Renderer
      threeRenderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        antialias: true,
        alpha: true 
      });
      threeRenderer.setSize(width, height);
      threeRenderer.setPixelRatio(window.devicePixelRatio);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      threeScene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      threeScene.add(directionalLight);
      
      // Ground plane (simple)
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a,
        roughness: 0.8
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      threeScene.add(ground);
      
      // Simple geometric shapes for visual interest
      const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
      const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff73 });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(0, 1, 0);
      threeScene.add(box);
      
      // Animation loop
      function animate() {
        threeAnimId = requestAnimationFrame(animate);
        
        // Rotate box slowly
        if (box) {
          box.rotation.y += 0.01;
        }
        
        threeRenderer.render(threeScene, threeCamera);
      }
      
      // Handle window resize
      window.addEventListener('resize', () => {
        if (!threeCamera || !threeRenderer) return;
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      animate();
      console.log('[Three.js] World Map initialized successfully');
    }
    
    function initThreeGarden() { 
      console.log("Initializing 2D Garden..."); 
      // Placeholder for mode-0 garden
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>