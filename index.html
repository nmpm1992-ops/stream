<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MewVolt Elite Casino Overlay</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Montserrat:wght@800&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Palette Premium BET */
      --bg-dark: #07080a;
      --panel-bg: rgba(12, 14, 18, 0.96);
      --neon-green: #00ff73;
      --neon-pink: #ff2975;
      --neon-blue: #00d2ff;
      --gold: #ffcc00;
      --glass-border: rgba(255, 255, 255, 0.08);
      --reel-bg: #050608;
      --text-main: #ffffff;
      --text-muted: #666666;
      --radius: 24px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; background: transparent; overflow: hidden; }
    body { font-family: 'Inter', sans-serif; color: var(--text-main); }

    /* --- BACKGROUND CANVAS --- */
    .gardenCanvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
    }

    /* --- HUD LAYOUT (MODE 3) --- */
    .hudContainer {
      position: fixed;
      inset: 0;
      display: none; /* Ativado via JS no mode-3 */
      grid-template-columns: 1fr 360px;
      grid-template-rows: 1fr auto;
      gap: 20px;
      padding: 30px 30px 30px 30px;
      padding-bottom: 0;
      z-index: 1000;
      pointer-events: none;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .hudContainer > * { pointer-events: auto; }
    
    .hudContainer > main,
    .hudContainer > aside {
      grid-row: 1;
      min-height: 0;
    }
    
    .hudContainer > footer {
      grid-column: 1 / -1;
      grid-row: 2;
      margin-top: 0;
      margin-left: -30px;
      margin-right: -30px;
      padding-bottom: 0;
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      visibility: visible;
      opacity: 1;
      width: calc(100% + 60px);
    }

    /* --- SLOT MACHINE HUD (LEFT) --- */
    .slotMachineHud {
      background: var(--panel-bg);
      backdrop-filter: blur(15px);
      border-radius: var(--radius);
      border: 1px solid var(--glass-border);
      display: flex;
      flex-direction: column;
      box-shadow: 0 40px 100px rgba(0,0,0,0.8);
      overflow: hidden;
      position: relative;
    }

    .slotMachineHud::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: var(--radius);
      padding: 2px;
      background: linear-gradient(45deg, 
        var(--neon-blue), 
        var(--neon-green), 
        var(--gold), 
        var(--neon-pink),
        var(--neon-blue)
      );
      background-size: 400% 400%;
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      animation: gradientBorder 3s ease infinite;
      z-index: -1;
    }

    @keyframes gradientBorder {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .slot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 25px 35px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid var(--glass-border);
    }

    .casino-brand {
      font-family: 'Montserrat', sans-serif;
      font-size: 22px;
      letter-spacing: 3px;
      font-weight: 900;
      background: linear-gradient(90deg, #fff, var(--neon-blue));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .jackpot-pill {
      background: linear-gradient(90deg, var(--gold), #d4a017);
      padding: 8px 24px;
      border-radius: 50px;
      color: #000;
      font-weight: 900;
      font-size: 14px;
      box-shadow: 0 0 25px rgba(255, 204, 0, 0.3);
      animation: pulse 2s infinite;
      position: relative;
      overflow: visible;
    }

    .jackpot-pill::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 50px;
      padding: 2px;
      background: linear-gradient(45deg, 
        var(--gold), 
        #d4a017, 
        var(--neon-green), 
        var(--gold)
      );
      background-size: 300% 300%;
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      animation: gradientBorder 2s ease infinite;
      z-index: -1;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .slot-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px;
      position: relative;
    }
    
    /* Commands help card */
    .commands-help {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 16px 20px;
      font-size: 11px;
      max-width: 280px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      z-index: 10;
    }
    
    .commands-help h4 {
      margin: 0 0 10px 0;
      font-size: 12px;
      font-weight: 800;
      color: var(--neon-blue);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .commands-help .cmd-item {
      margin: 8px 0;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .commands-help .cmd-item:last-child {
      border-bottom: none;
    }
    
    .commands-help .cmd-name {
      color: var(--gold);
      font-weight: 700;
      font-family: monospace;
      margin-right: 6px;
    }
    
    .commands-help .cmd-desc {
      color: var(--text-muted);
      font-size: 10px;
      line-height: 1.4;
      margin-top: 2px;
    }

    .status-box {
      background: rgba(255,255,255,0.02);
      border: 1px dashed rgba(255,255,255,0.1);
      padding: 15px 50px;
      border-radius: 15px;
      margin-bottom: 30px;
      text-align: center;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .status-box span { color: var(--neon-blue); font-family: monospace; font-size: 20px; font-weight: bold; }
    .status-box .player-info {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 5px;
    }
    .status-box .player-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--neon-blue);
      flex-shrink: 0;
    }
    .status-box .player-name {
      font-size: 14px;
      font-weight: 700;
      color: var(--neon-green);
    }
    .status-box .holder-badge {
      color: var(--gold);
      font-size: 10px;
      font-weight: 700;
      margin-left: 4px;
    }
    .status-box .phase-text {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 5px;
    }

    /* Slots Styling */
    .reels-container {
      display: flex;
      gap: 20px;
      position: relative;
    }

    .reel {
      width: 140px;
      height: 420px;
      background: linear-gradient(180deg, #0a0c0f 0%, #050608 50%, #0a0c0f 100%);
      border-radius: 16px;
      border: 3px solid rgba(255,255,255,0.08);
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      align-items: center;
      box-shadow: inset 0 0 50px rgba(0,0,0,0.9);
      position: relative;
      transition: all 0.3s ease;
      overflow: hidden;
    }

    .reel::after {
      content: '';
      position: absolute;
      inset: -3px;
      border-radius: 16px;
      padding: 3px;
      background: linear-gradient(45deg, 
        var(--neon-blue), 
        var(--neon-green), 
        var(--gold), 
        var(--neon-pink),
        var(--neon-blue)
      );
      background-size: 400% 400%;
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      animation: gradientBorder 3s ease infinite;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }

    .reel.spinning::after,
    .reel.slowing::after {
      opacity: 1;
    }

    .reel::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.05) 50%, 
        transparent 100%);
      pointer-events: none;
      z-index: 1;
    }

    .symbol { 
      font-size: 48px; 
      font-weight: 900;
      color: rgba(255,255,255,0.1); 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      position: relative;
      z-index: 2;
      transform: scale(0.9);
    }
    
    .symbol.active { 
      color: #fff; 
      transform: scale(1.15);
      text-shadow: 
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 60px currentColor;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .symbol.points { 
      color: var(--neon-green); 
      text-shadow: 
        0 0 25px var(--neon-green),
        0 0 50px var(--neon-green),
        0 0 75px var(--neon-green);
    }
    
    .symbol.jackpot { 
      color: var(--neon-pink); 
      text-shadow: 
        0 0 25px var(--neon-pink),
        0 0 50px var(--neon-pink),
        0 0 75px var(--neon-pink);
    }
    
    .symbol.nft { 
      color: var(--neon-blue); 
      text-shadow: 
        0 0 25px var(--neon-blue),
        0 0 50px var(--neon-blue),
        0 0 75px var(--neon-blue);
    }
    
    .symbol.extra { 
      color: var(--gold); 
      text-shadow: 
        0 0 25px var(--gold),
        0 0 50px var(--gold),
        0 0 75px var(--gold);
    }
    
    .symbol.empty { 
      color: rgba(255, 255, 255, 0.15); 
    }
    
    .reel.spinning {
      overflow: hidden;
      border-color: var(--neon-blue);
      box-shadow: 
        0 0 30px rgba(0, 210, 255, 0.6),
        0 0 60px rgba(0, 210, 255, 0.4),
        inset 0 0 30px rgba(0, 210, 255, 0.2);
      animation: reelShake 0.15s linear infinite;
      transform: perspective(1000px) rotateX(3deg);
    }

    @keyframes reelShake {
      0%, 100% { transform: perspective(1000px) rotateX(3deg) translateX(0); }
      25% { transform: perspective(1000px) rotateX(3deg) translateX(-2px); }
      75% { transform: perspective(1000px) rotateX(3deg) translateX(2px); }
    }
    
    .reel.spinning .symbol {
      animation: symbolSpin 0.12s linear infinite;
      color: rgba(255, 255, 255, 0.8);
    }

    @keyframes symbolSpin {
      0% { 
        transform: translateY(0) scale(0.9); 
        opacity: 0.3; 
      }
      50% { 
        opacity: 1; 
        transform: translateY(-140px) scale(1);
      }
      100% { 
        transform: translateY(-280px) scale(0.9); 
        opacity: 0.3; 
      }
    }

    .reel.spinning .symbol:nth-child(1) { 
      animation-delay: 0s; 
      animation-duration: 0.12s;
    }
    .reel.spinning .symbol:nth-child(2) { 
      animation-delay: 0.04s; 
      animation-duration: 0.11s;
    }
    .reel.spinning .symbol:nth-child(3) { 
      animation-delay: 0.08s; 
      animation-duration: 0.13s;
    }

    .reel.slowing {
      border-color: var(--neon-green);
      box-shadow: 
        0 0 40px rgba(0, 255, 115, 0.5),
        0 0 80px rgba(0, 255, 115, 0.3),
        inset 0 0 40px rgba(0, 255, 115, 0.15);
      animation: reelSlow 0.3s ease-out infinite;
    }

    @keyframes reelSlow {
      0%, 100% { transform: perspective(1000px) rotateX(3deg) translateX(0); }
      50% { transform: perspective(1000px) rotateX(3deg) translateX(-1px); }
    }

    @keyframes symbolSpinSlow {
      0% { 
        transform: translateY(0) scale(0.9); 
        opacity: 0.3; 
      }
      50% { 
        opacity: 1; 
        transform: translateY(-140px) scale(1);
      }
      100% { 
        transform: translateY(-280px) scale(0.9); 
        opacity: 0.3; 
      }
    }

    .win-line {
      position: absolute;
      top: 50%;
      left: -10px;
      right: -10px;
      height: 100px;
      transform: translateY(-50%);
      border: 2px solid var(--neon-green);
      background: rgba(0, 255, 115, 0.05);
      box-shadow: 0 0 30px rgba(0, 255, 115, 0.2);
      border-radius: 16px;
      pointer-events: none;
      z-index: 5;
    }

    /* --- SIDEBAR WIDGETS --- */
    .sidebar { display: flex; flex-direction: column; gap: 15px; }

    .widget {
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .widget::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: 20px;
      padding: 1px;
      background: linear-gradient(45deg, 
        var(--neon-blue), 
        var(--neon-green), 
        var(--gold), 
        var(--neon-pink),
        var(--neon-blue)
      );
      background-size: 400% 400%;
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      animation: gradientBorder 4s ease infinite;
      opacity: 0.3;
      z-index: -1;
    }

    .widget-header {
      padding: 12px 18px;
      background: rgba(255,255,255,0.03);
      font-size: 10px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text-muted);
      border-bottom: 1px solid rgba(255,255,255,0.03);
      display: flex;
      justify-content: space-between;
      position: relative;
    }

    .widget-header::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent, 
        var(--neon-blue), 
        var(--neon-green), 
        var(--gold),
        transparent
      );
      background-size: 300% 100%;
      animation: gradientBorder 3s ease infinite;
    }

    .widget-body { padding: 15px; font-size: 13px; overflow: hidden; flex: 1; word-wrap: break-word; display: flex; flex-direction: column; }

    .item-row { margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.02); word-wrap: break-word; overflow-wrap: break-word; display: flex; align-items: center; gap: 8px; }
    .item-row .avatar { width: 24px; height: 24px; border-radius: 50%; object-fit: cover; flex-shrink: 0; border: 1px solid rgba(255,255,255,0.1); }
    .item-row .content { flex: 1; min-width: 0; }
    .user { color: var(--neon-green); font-weight: 700; }
    .msg { color: #bbb; display: block; margin-top: 2px; word-wrap: break-word; overflow-wrap: break-word; }
    .ts { float: right; color: rgba(255,255,255,0.4); font-size: 10px; }

    /* --- FOOTER & DISCLAIMER --- */
    .hud-footer {
      grid-column: 1 / -1;
      padding: 0;
      position: relative;
      overflow: visible;
      display: flex !important;
      flex-direction: column;
      width: 100%;
      visibility: visible !important;
      opacity: 1 !important;
      z-index: 100;
    }

    .rules-header {
      background: transparent;
      backdrop-filter: none;
      border-top: none;
      padding: 20px 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      position: relative;
      z-index: 9999;
      overflow: hidden;
    }

    .rules-header::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(0, 210, 255, 0.15) 25%,
        rgba(255, 41, 117, 0.15) 50%,
        rgba(0, 210, 255, 0.15) 75%,
        transparent 100%
      );
      background-size: 200% 100%;
      animation: gradientShift 4s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .rules-header::after {
      content: '';
      position: absolute;
      inset: 0;
      box-shadow: 
        inset 0 0 60px rgba(0, 210, 255, 0.2),
        inset 0 0 100px rgba(255, 41, 117, 0.15),
        0 0 40px rgba(0, 210, 255, 0.3),
        0 0 80px rgba(255, 41, 117, 0.2);
      animation: glowPulse 3s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes glowPulse {
      0%, 100% { 
        box-shadow: 
          inset 0 0 60px rgba(0, 210, 255, 0.2),
          inset 0 0 100px rgba(255, 41, 117, 0.15),
          0 0 40px rgba(0, 210, 255, 0.3),
          0 0 80px rgba(255, 41, 117, 0.2);
      }
      50% { 
        box-shadow: 
          inset 0 0 80px rgba(0, 210, 255, 0.3),
          inset 0 0 120px rgba(255, 41, 117, 0.25),
          0 0 60px rgba(0, 210, 255, 0.4),
          0 0 100px rgba(255, 41, 117, 0.3);
      }
    }

    .rules-title-card {
      display: flex;
      align-items: center;
      gap: 20px;
      position: relative;
      z-index: 2;
    }

    .rules-title-icon {
      font-size: 48px;
      line-height: 1;
      filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.6)) drop-shadow(0 0 30px rgba(255, 41, 117, 0.4));
      animation: titlePulse 2s ease-in-out infinite;
      text-shadow: 0 0 20px currentColor;
    }

    @keyframes titlePulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.6)) drop-shadow(0 0 30px rgba(255, 41, 117, 0.4)); }
      50% { transform: scale(1.1); filter: drop-shadow(0 0 25px rgba(0, 210, 255, 0.8)) drop-shadow(0 0 40px rgba(255, 41, 117, 0.6)); }
    }

    .rules-title-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .rules-title-main {
      font-size: 24px;
      font-weight: 900;
      background: linear-gradient(90deg, 
        rgba(0, 210, 255, 1) 0%, 
        rgba(255, 41, 117, 1) 50%, 
        rgba(0, 210, 255, 1) 100%);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: 3px;
      text-transform: uppercase;
      text-shadow: 
        0 0 20px rgba(0, 210, 255, 0.5),
        0 0 40px rgba(255, 41, 117, 0.3);
      font-family: 'Montserrat', sans-serif;
      animation: textGradientShift 3s ease-in-out infinite;
      filter: drop-shadow(0 0 15px rgba(0, 210, 255, 0.5)) drop-shadow(0 0 25px rgba(255, 41, 117, 0.3));
    }

    @keyframes textGradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .rules-title-sub {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.7);
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .rules-ticker {
      background: transparent;
      backdrop-filter: none;
      border-top: none;
      border-radius: 0;
      padding: 28px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      min-height: 110px;
      width: 100%;
    }

    .rules-ticker::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 300px;
      background: linear-gradient(90deg, var(--bg-dark) 0%, transparent 100%);
      z-index: 3;
      pointer-events: none;
    }

    .rules-ticker::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 300px;
      background: linear-gradient(270deg, var(--bg-dark) 0%, transparent 100%);
      z-index: 3;
      pointer-events: none;
    }

    .rules-content {
      display: flex;
      align-items: center;
      gap: 50px;
      animation: scrollRules 80s linear infinite;
      white-space: nowrap;
      padding: 0 60px;
    }

    @keyframes scrollRules {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .rules-content:hover {
      animation-play-state: paused;
    }

    .rule-item {
      display: flex;
      align-items: center;
      gap: 18px;
      padding: 16px 32px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
      border-radius: 18px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      font-size: 15px;
      color: var(--text-main);
      white-space: nowrap;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      min-height: 70px;
    }

    .rule-item:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.05) 100%);
      border-color: rgba(255, 255, 255, 0.2);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
    }

    .rule-item .icon {
      font-size: 28px;
      line-height: 1;
    }

    .rule-item .prize-icon {
      font-size: 36px;
      font-weight: 900;
      text-shadow: 0 0 15px currentColor;
      line-height: 1;
    }

    .rule-item .prize-icon.jackpot { color: var(--neon-pink); }
    .rule-item .prize-icon.points { color: var(--neon-green); }
    .rule-item .prize-icon.nft { color: var(--neon-blue); }
    .rule-item .prize-icon.extra { color: var(--gold); }

    .rule-item .text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .rule-item .main-text {
      font-weight: 800;
      color: #fff;
      font-size: 16px;
      letter-spacing: 0.5px;
    }

    .rule-item .sub-text {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .rule-separator {
      width: 3px;
      height: 50px;
      background: linear-gradient(180deg, transparent, var(--glass-border), transparent);
      opacity: 0.4;
    }

    .disclaimer {
      font-size: 11px;
      color: #777;
      max-width: 100%;
      margin: 0;
      line-height: 1.8;
      padding: 20px 30px;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(7, 8, 10, 0.98) 0%, rgba(5, 6, 8, 1) 100%);
      backdrop-filter: blur(10px);
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      width: 100%;
      box-sizing: border-box;
    }

    .disclaimer b {
      color: #aaa;
      font-weight: 700;
    }

    /* --- COMPATIBILITY TOPBAR (MODES 0, 1, 2) --- */
    .topbar {
      position: absolute; left: 24px; right: 24px; top: 18px;
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 20px;
      border: 1px solid var(--glass-border);
      background: var(--panel-bg);
      border-radius: 18px;
      z-index: 2000;
      backdrop-filter: blur(10px);
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .logo img { width: 40px; height: 40px; border-radius: 10px; }
    .pill { font-size: 13px; color: var(--text-muted); }
    .pill strong { color: #fff; }

    /* Helper Classes */
    .hidden { display: none !important; }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-thumb { background: #222; border-radius: 10px; }
  </style>
</head>
<body>

  <!-- AUDIO ELEMENTS -->
  <audio id="slotSfxIntro" preload="auto"><source src="audio/slotSfxIntro.wav" type="audio/wav"></audio>
  <audio id="slotSfxSpin" preload="auto"><source src="audio/slotSfxSpin.MP3" type="audio/mpeg"></audio>
  <audio id="slotSfxNext" preload="auto"><source src="audio/slotSfxNext.wav" type="audio/wav"></audio>
  <audio id="bgm" preload="auto" loop><source src="audio/bgm.mp3" type="audio/mpeg"></audio>

  <canvas class="gardenCanvas" id="gardenCanvas"></canvas>

  <!-- ELITE HUD (MODE 3) -->
  <div class="hudContainer" id="hudContainer">
    <!-- SLOT AREA -->
    <main class="slotMachineHud">
      <header class="slot-header">
        <div class="casino-brand">MEWVOLT CASINO</div>
        <div class="jackpot-pill" id="slotJackpot">JACKPOT: 0.25 SOL</div>
        <div style="font-size: 11px; color: var(--neon-green);" id="slotLive">LIVE 00:00:00</div>
      </header>

      <div class="slot-body">
        <div class="status-box" id="statusBox">
          <p style="font-size: 10px; color: #555; margin-bottom: 5px; font-weight: 900;">SYSTEM READY</p>
          <div>Type <span>/start</span> in chat to join</div>
      </div>

        <div id="slotRulesBreak" class="hidden" style="text-align:center; max-width: 500px;">
          <h3 id="slotRulesTitle" style="color:var(--gold)">Rules</h3>
          <p id="slotRulesText" style="font-size: 18px;"></p>
          <p id="slotRulesDetail" style="color:#555; font-size: 12px; margin-top:10px;"></p>
      </div>

        <div class="reels-container" id="slotGrid">
          <div class="win-line"></div>
          
          <div class="reel">
            <div class="symbol points active">10</div>
            <div class="symbol jackpot active">7</div>
            <div class="symbol empty">â€”</div>
      </div>
          <div class="reel">
            <div class="symbol extra">SPIN</div>
            <div class="symbol nft active">NFT</div>
            <div class="symbol points">25</div>
      </div>
          <div class="reel">
            <div class="symbol jackpot active">7</div>
            <div class="symbol empty">â€”</div>
            <div class="symbol points">50</div>
    </div>
    </div>

        <h2 style="margin-top: 40px; font-weight: 900; letter-spacing: 5px; color: rgba(255,255,255,0.05)" id="slotWaiting">WAITING FOR BETS</h2>
        
        <!-- Commands Help Card -->
        <div class="commands-help">
          <h4>ðŸ“‹ Commands</h4>
          <div class="cmd-item">
            <div><span class="cmd-name">/start</span> or <span class="cmd-name">/spin</span></div>
            <div class="cmd-desc">Join the slot queue. HOLDERS: 3 spins/day â€¢ Non-HOLDERS: 1 spin/day</div>
          </div>
          <div class="cmd-item">
            <div><span class="cmd-name">/points</span></div>
            <div class="cmd-desc">Check your current points. Collect 1000 points to win 1000 MEWVOLT!</div>
          </div>
          <div class="cmd-item">
            <div style="color: var(--neon-green); font-size: 10px; margin-top: 6px;">
              ðŸ’¡ Points are earned by spinning the slot machine
            </div>
          </div>
        </div>
      </div>

      <div style="padding: 10px; text-align: center; background: rgba(0,0,0,0.2); font-size: 11px; color: rgba(255,255,255,0.5);" id="slotDateTime">00/00/0000 00:00:00</div>
    </main>

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <!-- LOGS -->
      <div class="widget" style="height: 220px;">
        <div class="widget-header">
          <span>Activity Logs</span>
          <span id="slotQueue" style="color:var(--neon-blue); font-size: 9px; line-height: 1.4;">Q: 0</span>
    </div>
        <div class="widget-body" id="logsList"></div>
    </div>

      <!-- WINNERS -->
      <div class="widget" style="height: 180px;">
        <div class="widget-header">Recent Winners</div>
        <div class="widget-body" id="winnersList"></div>
    </div>

      <!-- CHAT -->
      <div class="widget" style="flex: 1;">
        <div class="widget-header">Community Chat</div>
        <div class="widget-body" id="chatMessages"></div>
      </div>
    </aside>

    <footer class="hud-footer">
      <div class="rules-header">
        <div class="rules-title-card">
          <span class="rules-title-icon">ðŸŽ°</span>
          <div class="rules-title-text">
            <span class="rules-title-main">RULES / REWARDS</span>
            <span class="rules-title-sub">Game Information</span>
          </div>
        </div>
      </div>
      <div class="rules-ticker">
        <div class="rules-content" id="rulesContent">
          <!-- Rules will be populated by JavaScript -->
        </div>
      </div>
      <p class="disclaimer">
        <b>RISK WARNING:</b> $MewVolt is a digital memecoin for entertainment purposes only. It has no intrinsic value. 
        Crypto markets are highly volatile. You may lose your entire investment. 
        This is a gaming simulation and not financial advice. <b>Always Do Your Own Research (DYOR) before investing in $MewVolt.</b>
      </p>
    </footer>
    </div>

  <!-- FALLBACK TOPBAR (MODE 0,1,2) -->
  <div class="topbar" id="oldTopbar">
    <div class="brand">
      <div class="logo"><img src="https://mewvolt.online/logo.png" alt="MeVolt" /></div>
      <div class="btext"><strong>MeVolt</strong> <span style="font-size:10px; color:#555;">Dev</span></div>
      </div>
    <div class="pill">Price: <strong id="priceVal">â€”</strong> SOL</div>
    <div class="pill">MCap: <strong id="marketCap">â€”</strong></div>
    <div class="pill">Holders: <strong id="holders">â€”</strong></div>
      </div>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

  <script>
    // --- USER CONFIG & STATE ---
    const CONFIG = {
      contract: 'CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump',
      pumpUrl: 'https://pump.fun/coin/CpqA1pwX5SjU1SgufRwQ59knKGaDMEQ7MQBeu6mpump',
      wsUrl: 'wss://pumpportal.fun/api/data',
      chatWsUrl: 'https://livechat.pump.fun',
      corsProxies: ['https://corsproxy.io/?', 'https://api.allorigins.win/raw?url='],
      minBuyThreshold: 0.01
    };

    let coinData = { viewers: null, marketCap: null, holders: null, price: null };
    let slotState = { 
      queue: [], 
      jackpot: 1000, 
      userPoints: {}, 
      winners: [], 
      lastResetDate: new Date().toDateString(),
      dailySpins: {}, // Tracking spins per wallet per day
      dailyNFTCount: 0, // Global daily NFT count
      dailyPurchasesSOL: 0, // SOL purchases today
      yesterdayPurchasesSOL: 0 // SOL purchases yesterday (for jackpot calculation)
    };
    let processedTxSignatures = new Set();
    let chatEntries = [];
    let logEntries = [];
    let winnersEntries = [];
    let slotCurrent = null;
    let userInfoCache = {}; // Cache: { wallet|username: { avatarUrl, isHolder, userAddress } }

    // --- MODE DETECTION ---
    const urlParams = new URLSearchParams(window.location.search);
    const pageId = urlParams.get('id') || '3';

    // --- INITIALIZATION ---
    function init() {
      // Start background music
      const bgm = document.getElementById('bgm');
      if (bgm) {
        bgm.volume = 0.3; // Set volume to 30%
        bgm.play().catch(e => console.warn('[Audio] BGM play error (may require user interaction):', e));
      }

      // Toggle UI visibility
      if (pageId === '3') {
        document.getElementById('hudContainer').style.display = 'grid';
        document.getElementById('oldTopbar').classList.add('hidden');
        initThreeWorldMap(); // Start the 3D map
      } else {
        document.getElementById('hudContainer').classList.add('hidden');
        if (pageId === '0') initThreeGarden(); 
      }

      // Start Data Loops
      fetchAllCoinData();
      setInterval(fetchAllCoinData, 10000);
      
      // Slot System
      loadPersistentData().then(async () => {
        await checkDailyReset();
        await updateJackpot();
      });
      setInterval(updateSlotLiveTimer, 1000);
      setInterval(updateDateTime, 1000);
      setInterval(() => { checkDailyReset(); }, 60000); // Check daily reset every minute

      // Initialize rules ticker
      initRulesTicker();

      // Connections
      connectWS();
      connectChatWS();
    }

    // Initialize rules ticker in footer
    function initRulesTicker() {
      const rulesContent = document.getElementById('rulesContent');
      if (!rulesContent) return;

      const rules = [
        { icon: 'ðŸŽ°', main: 'JACKPOT', sub: '5% chance â€¢ MEWVOLT', class: 'jackpot' },
        { icon: 'ðŸ’Ž', main: '50 POINTS', sub: '5% chance', class: 'points' },
        { icon: 'ðŸŽ¨', main: 'FREE MINT NFT', sub: '10% chance â€¢ Max 2/day', class: 'nft' },
        { icon: 'â­', main: '25 POINTS', sub: '10% chance', class: 'points' },
        { icon: 'âœ¨', main: '10 POINTS', sub: '15% chance', class: 'points' },
        { icon: 'ðŸ”„', main: 'EXTRA SPIN', sub: '15% chance â€¢ Free play', class: 'extra' },
        { icon: 'ðŸ’¼', main: 'HOLDER', sub: '3 spins/day â€¢ â‰¥$5 MEWVOLT', class: 'points' },
        { icon: 'ðŸ‘¤', main: 'NON-HOLDER', sub: '1 spin/day', class: 'points' },
        { icon: 'ðŸ†', main: '1000 POINTS', sub: 'Reward: 1000 MEWVOLT', class: 'points' },
        { icon: 'ðŸ’°', main: 'JACKPOT ROLLOVER', sub: 'Accumulates if not won', class: 'jackpot' },
        { icon: 'ðŸŽ¯', main: 'COMMANDS', sub: '/start â€¢ /points', class: 'extra' },
        { icon: 'ðŸ“Š', main: 'NOTHING', sub: '40% chance', class: 'points' }
      ];

      // Duplicate rules for seamless loop
      const allRules = [...rules, ...rules];
      
      rulesContent.innerHTML = allRules.map((rule, idx) => {
        const separator = idx > 0 ? '<div class="rule-separator"></div>' : '';
        return `${separator}
          <div class="rule-item">
            <span class="prize-icon ${rule.class}">${rule.icon}</span>
            <div class="text">
              <span class="main-text">${rule.main}</span>
              <span class="sub-text">${rule.sub}</span>
            </div>
          </div>`;
      }).join('');
    }

    // --- DATA FETCHING (Pump.fun / DexScreener) ---
    async function fetchAllCoinData() {
      try {
        const dexUrl = `https://api.dexscreener.com/latest/dex/tokens/${CONFIG.contract}`;
        const res = await fetch(dexUrl);
        const data = await res.json();
        if (data.pairs && data.pairs[0]) {
          const p = data.pairs[0];
          document.getElementById('priceVal').textContent = parseFloat(p.priceNative).toFixed(8);
          document.getElementById('marketCap').textContent = '$' + (p.marketCap / 1000000).toFixed(2) + 'M';
          // Sync with Elite HUD
          if (pageId === '3') {
            document.getElementById('slotJackpot').textContent = `JACKPOT: ${slotState.jackpot.toFixed(0)} MEWVOLT`;
          }
        }
      } catch (e) { console.log("Data fetch error", e); }
    }

    // --- WEBSOCKETS (Trades & Chat) ---
    function connectWS() {
      const ws = new WebSocket(CONFIG.wsUrl);
      ws.onopen = () => ws.send(JSON.stringify({ method: 'subscribeTokenTrade', keys: [CONFIG.contract] }));
      ws.onmessage = (e) => {
        const data = JSON.parse(e.data);
        if (data.txType === 'buy') {
          handleBuy(data.traderPublicKey, data.solAmount);
        }
      };
      ws.onclose = () => setTimeout(connectWS, 3000);
    }

    function handleBuy(wallet, sol) {
      if (sol >= CONFIG.minBuyThreshold) {
        addLog(`ðŸ’° New Buy! ${wallet.slice(0,4)}... paid ${sol.toFixed(2)} SOL`, '#00ff73');
        // 4. Track purchases for jackpot calculation
        slotState.dailyPurchasesSOL = (slotState.dailyPurchasesSOL || 0) + sol;
        saveSlotState(); // Persist state
      }
    }

    function connectChatWS() {
      // Preferred: use local SSE proxy (avoids browser CORS/auth issues with livechat.pump.fun)
      if (typeof EventSource !== 'undefined') {
        // Use commands=1 to get command events directly from server
        const sseUrl = `/chat-sse?room=${encodeURIComponent(CONFIG.contract)}&commands=1`;
        console.log('[Chat] Connecting via SSE:', sseUrl);

        try {
          const es = new EventSource(sseUrl);

          es.onopen = () => {
            console.log('[Chat] SSE connected');
          };

          es.onerror = (err) => {
            console.warn('[Chat] SSE error (will retry automatically):', err);
          };

          es.onmessage = (ev) => {
            try {
              const msg = JSON.parse(ev.data);
              console.log('[Chat] SSE onmessage received:', msg);
              // Server sends: { event: 'newMessage', data: {...} }
              if (msg && msg.data) {
                processChatMessage(msg);
              } else if (msg && !msg.event) {
                // Direct message data without envelope
                processChatMessage(msg);
              }
            } catch (e) {
              console.warn('[Chat] SSE parse error:', e, ev.data);
            }
          };

          // Listen for specific SSE events (newMessage, command, etc.)
          es.addEventListener('newMessage', (ev) => {
            try {
              const payload = JSON.parse(ev.data);
              console.log('[Chat] SSE newMessage event payload:', payload);
              // Payload can be direct message data or wrapped in { event, data }
              if (payload && payload.data) {
                processChatMessage(payload);
              } else {
                // Direct payload is the message data itself
                processChatMessage({ event: 'newMessage', data: payload });
              }
            } catch (e) {
              console.warn('[Chat] SSE newMessage parse error:', e, ev.data);
            }
          });

          es.addEventListener('command', (ev) => {
            try {
              const cmd = JSON.parse(ev.data);
              console.log('[Chat] SSE command event received:', cmd);
              
              // Server sends: { cmd, text, userAddress, username, ... }
              const text = cmd.text || (cmd.cmd ? `/${cmd.cmd}` : '');
              const wallet = cmd.userAddress || cmd.wallet || null;
              const username = cmd.username || cmd.user || 'User';
              
              if (text) {
                console.log('[Chat] Processing command from SSE:', { text, username, wallet });
                processChatCommand(text, username, { wallet, userAddress: wallet, ...cmd });
              } else {
                console.warn('[Chat] SSE command missing text:', cmd);
              }
            } catch (e) {
              console.warn('[Chat] SSE command parse error:', e, ev.data);
            }
          });

          es.addEventListener('message', (ev) => {
            try {
              const payload = JSON.parse(ev.data);
              if (payload && payload.data) {
                processChatMessage(payload);
                } else {
                processChatMessage({ event: 'message', data: payload });
              }
            } catch (e) {
              console.warn('[Chat] SSE message parse error:', e);
            }
          });

          // Listen for other message-related events
          ['chat_message', 'new_message', 'msg', 'room_message', 'chat'].forEach(eventName => {
            es.addEventListener(eventName, (ev) => {
              try {
                const payload = JSON.parse(ev.data);
                if (payload && payload.data) {
                  processChatMessage(payload);
          } else {
                  processChatMessage({ event: eventName, data: payload });
                }
              } catch (e) {
                console.warn(`[Chat] SSE ${eventName} parse error:`, e);
              }
            });
          });

          window.addEventListener('beforeunload', () => {
            try { es.close(); } catch {}
          });

          return;
        } catch (e) {
          console.warn('[Chat] SSE init failed, falling back to Socket.IO:', e);
        }
      }

      // Fallback: direct Socket.IO (may fail due to CORS/auth)
        if (typeof io === 'undefined') {
        console.warn('[Chat] Socket.IO not loaded');
          return;
        }

      console.log('[Chat] Connecting to', CONFIG.chatWsUrl);
      const socket = io(CONFIG.chatWsUrl, {
        transports: ['websocket', 'polling'],
          reconnection: true,
        reconnectionDelay: 2000
      });

      socket.on('connect', () => {
        console.log('[Chat] Connected, joining room:', CONFIG.contract);
        socket.emit('join_room', CONFIG.contract);
        socket.emit('joinRoom', { roomId: CONFIG.contract, username: 'overlay' }, (ack) => {
          console.log('[Chat] joinRoom ack:', ack);
        });
        socket.emit('subscribe', { room: CONFIG.contract });
      });

      socket.on('disconnect', () => {
        console.log('[Chat] Disconnected');
      });

      socket.on('connect_error', (err) => {
        console.error('[Chat] Connection error:', err);
      });

      socket.on('newMessage', (data) => {
        console.log('[Chat] Received newMessage event:', data);
        processChatMessage(data);
      });

      socket.onAny((eventName, ...args) => {
        const ev = String(eventName || '').toLowerCase();
        if (ev.includes('message') || ev.includes('chat')) {
          console.log('[Chat] Event:', eventName, args);
          if (args[0]) processChatMessage(args[0]);
        }
      });
    }

    function processChatMessage(data) {
      console.log('[Chat] processChatMessage called with:', data);
      
      // Handle different data formats
      let user, text, wallet;

      // Unwrap SSE envelope: { event, data }
      // Store original data for extracting profile_image after unwrap
      const originalData = data;
      if (data && typeof data === 'object' && data.data && (data.event || data.type)) {
        data = data.data;
      }
      
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
      } catch {
          // If we can't parse, skip this message (it's likely not a valid chat message)
          console.log('[Chat] Skipping unparseable string message:', data);
          return;
        }
      }
      
      console.log('[Chat] After unwrap, data is:', data);
      console.log('[Chat] Debug - data.profile_image:', data?.profile_image);
      console.log('[Chat] Debug - data.raw?.profile_image:', data?.raw?.profile_image);
      console.log('[Chat] Debug - originalData.data?.profile_image:', originalData?.data?.profile_image);
      console.log('[Chat] Debug - data object keys:', data ? Object.keys(data) : 'no data');
      if (data && data.raw) {
        console.log('[Chat] Debug - data.raw object keys:', Object.keys(data.raw));
      }
      
      // Extract username - if we don't have a valid username, skip the message
      user = data.user || data.username || data.name || null;
      if (!user || typeof user !== 'string') {
        console.log('[Chat] Skipping message without valid username:', data);
        return;
      }
      
      text = data.text || data.message || data.msg || data.content || "";
      wallet = data.wallet || data.userAddress || data.address || null;

      // Filter out generic/invalid usernames (case-insensitive, with or without colon)
      const normalizedUser = (user || '').trim().toLowerCase();
      if (normalizedUser === 'user' || normalizedUser === 'user:' || normalizedUser === '' || !normalizedUser || normalizedUser.startsWith('user')) {
        console.log('[Chat] Skipping message with invalid username:', user);
        return;
      }
      
      // Filter out system/debug messages
      const normalizedText = (text || '').trim().toLowerCase();
      const systemMessages = [
        'chat config',
        'livestream join',
        'joinroom ack',
        'joining rooms',
        'connected',
        'disconnected',
        'subscribe',
        'join_room',
        'ack'
      ];
      if (systemMessages.some(msg => normalizedText.includes(msg))) {
        console.log('[Chat] Skipping system/debug message:', text);
        return;
      }

      // Normalize text payloads (Pump.fun often sends { message: string|array })
      if (Array.isArray(text)) {
        text = String(text[0] || '');
      } else if (typeof text !== 'string') {
        text = text == null ? '' : String(text);
      }
      
      if (!text || !text.trim()) {
        console.log('[Chat] Skipping empty message:', data);
        return;
      }
      
      // Only process messages that contain "/" (commands)
      const normalizedTextForCommand = (text || '').trim();
      if (!normalizedTextForCommand.includes('/')) {
        console.log('[Chat] Skipping message without command (no "/"):', text);
        return;
      }

      console.log('[Chat] Processing message:', { user, text: text.substring(0, 50), wallet });

      // Check for duplicates (same user + message within last 2 seconds)
      const now = Date.now();
      const isDuplicate = chatEntries.some(e => 
        e.username === user && e.message === text && Math.abs(e.timestamp - now) < 2000
      );
      if (isDuplicate) {
        console.log('[Chat] Skipping duplicate message');
        return;
      }

      // Extract profile_image from data or originalData (in case it's in the unwrapped format)
      // Priority: data.profile_image (after unwrap) > originalData.data.profile_image > other paths
      // This ensures we get the profile_image from the correct location
      let avatarUrl = '';
      
      // Try data.profile_image first (most common after unwrap)
      if (data && typeof data === 'object' && 'profile_image' in data && data.profile_image) {
        avatarUrl = String(data.profile_image).trim();
      }
      // Try data.raw.profile_image (sometimes profile_image is nested in raw property)
      else if (data && data.raw && typeof data.raw === 'object' && 'profile_image' in data.raw && data.raw.profile_image) {
        avatarUrl = String(data.raw.profile_image).trim();
      }
      // Try originalData.data.profile_image (before unwrap)
      else if (originalData && originalData.data && typeof originalData.data === 'object' && 'profile_image' in originalData.data && originalData.data.profile_image) {
        avatarUrl = String(originalData.data.profile_image).trim();
      }
      // Try other paths as fallback
      else if (data && data.avatarUrl) {
        avatarUrl = String(data.avatarUrl).trim();
      }
      else if (data && data.profileImage) {
        avatarUrl = String(data.profileImage).trim();
      }
      else if (originalData && originalData.data && originalData.data.avatarUrl) {
        avatarUrl = String(originalData.data.avatarUrl).trim();
      }
      else if (originalData && originalData.profile_image) {
        avatarUrl = String(originalData.profile_image).trim();
      }
      else if (originalData && originalData.avatarUrl) {
        avatarUrl = String(originalData.avatarUrl).trim();
      }
      
      console.log('[Chat] Extracted avatar:', { 
        avatarUrl, 
        hasData: !!data, 
        hasOriginal: !!originalData,
        dataKeys: data ? Object.keys(data) : [],
        originalKeys: originalData ? Object.keys(originalData) : [],
        dataProfileImage: data?.profile_image,
        dataAvatarUrl: data?.avatarUrl
      });
      
      const chatEntry = { username: user, message: text, timestamp: now, avatarUrl, userAddress: wallet, isHolder: false };
      chatEntries.push(chatEntry);
      console.log('[Chat] Added chat entry, total entries:', chatEntries.length, 'new entry:', chatEntry);
      if (chatEntries.length > 50) chatEntries.shift();
      
      // Update user info cache
      const cacheKey = wallet && wallet !== 'unknown' ? wallet : `user:${user.toLowerCase()}`;
      if (!userInfoCache[cacheKey]) {
        userInfoCache[cacheKey] = {};
      }
      if (avatarUrl) {
        userInfoCache[cacheKey].avatarUrl = avatarUrl;
      }
      if (wallet && wallet !== 'unknown') {
        userInfoCache[cacheKey].userAddress = wallet;
      }
      
      // Check holder status asynchronously
      if (wallet && wallet !== 'unknown') {
        console.log('[Chat] Checking holder status for wallet:', wallet);
        checkIsHolder(wallet).then(isHolder => {
          console.log('[Chat] Holder check result:', { wallet, isHolder });
          chatEntry.isHolder = isHolder;
          userInfoCache[cacheKey].isHolder = isHolder;
          console.log('[Chat] Holder status updated:', { username: user, wallet, isHolder, cacheKey, chatEntry });
          
          // Update existing log entries for this user
          logEntries.forEach(logEntry => {
            if (logEntry.userAddress === wallet || 
                (logEntry.username === user && !logEntry.userAddress)) {
              logEntry.isHolder = isHolder;
              console.log('[Chat] Updated log entry holder status:', { username: logEntry.username, isHolder });
            }
          });
          
          // Update existing winner entries for this user
          winnersEntries.forEach(winnerEntry => {
            if (winnerEntry.userAddress === wallet || 
                (winnerEntry.username === user && !winnerEntry.userAddress)) {
              winnerEntry.isHolder = isHolder;
              console.log('[Chat] Updated winner entry holder status:', { username: winnerEntry.username, isHolder });
            }
          });
          
          // Update all HUDs to reflect the new holder status
          updateChatHud();
          updateLogsHud();
          updateWinnersHud();
        }).catch((err) => {
          console.warn('[Chat] Holder check failed:', err);
          chatEntry.isHolder = false;
          userInfoCache[cacheKey].isHolder = false;
        });
      } else {
        console.log('[Chat] Skipping holder check - no valid wallet:', wallet);
      }
      
      console.log('[Chat] Calling updateChatHud(), chatEntries.length:', chatEntries.length);
      updateChatHud();

      // Save to drive_db - ensure avatarUrl is saved correctly
      // Double-check avatarUrl extraction right before saving, checking all possible paths
      let finalAvatarUrl = avatarUrl || '';
      
      // If avatarUrl is empty, try all possible extraction paths again
      if (!finalAvatarUrl || !finalAvatarUrl.trim()) {
        if (data && typeof data === 'object' && 'profile_image' in data && data.profile_image) {
          finalAvatarUrl = String(data.profile_image).trim();
        }
        else if (data && data.raw && typeof data.raw === 'object' && 'profile_image' in data.raw && data.raw.profile_image) {
          finalAvatarUrl = String(data.raw.profile_image).trim();
        }
        else if (originalData && originalData.data && typeof originalData.data === 'object' && 'profile_image' in originalData.data && originalData.data.profile_image) {
          finalAvatarUrl = String(originalData.data.profile_image).trim();
        }
        else if (data && data.avatarUrl) {
          finalAvatarUrl = String(data.avatarUrl).trim();
        }
        else if (originalData && originalData.data && originalData.data.avatarUrl) {
          finalAvatarUrl = String(originalData.data.avatarUrl).trim();
        }
      }
      
      const chatToSave = {
        ts: Date.now(),
        id: data.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        username: user,
        avatarUrl: finalAvatarUrl || '', // Use final extracted avatarUrl
        text: text,
        userAddress: wallet
      };
      // Final verification: if still empty, try accessing directly with bracket notation
      if (!finalAvatarUrl || !finalAvatarUrl.trim()) {
        // Try direct property access with bracket notation (in case property exists but 'in' operator fails)
        if (data && data['profile_image']) {
          finalAvatarUrl = String(data['profile_image']).trim();
        }
        else if (data && data.raw && data.raw['profile_image']) {
          finalAvatarUrl = String(data.raw['profile_image']).trim();
        }
        else if (originalData && originalData.data && originalData.data['profile_image']) {
          finalAvatarUrl = String(originalData.data['profile_image']).trim();
        }
        
        // Update chatToSave with final value
        if (finalAvatarUrl && finalAvatarUrl.trim()) {
          chatToSave.avatarUrl = finalAvatarUrl;
        }
      }
      
      console.log('[Chat] Saving to drive_db:', { 
        username: chatToSave.username, 
        avatarUrl: chatToSave.avatarUrl, 
        hasAvatarUrl: !!chatToSave.avatarUrl && chatToSave.avatarUrl.length > 0,
        extractedAvatarUrl: avatarUrl,
        finalAvatarUrl: finalAvatarUrl,
        chatToSaveAvatarUrl: chatToSave.avatarUrl,
        dataProfileImage: data?.profile_image,
        dataRawProfileImage: data?.raw?.profile_image,
        originalDataProfileImage: originalData?.data?.profile_image,
        dataKeys: data ? Object.keys(data) : [],
        originalDataKeys: originalData ? Object.keys(originalData) : [],
        fullDataObject: JSON.stringify(data).substring(0, 500)
      });
      saveToDriveDb({
        chats: [chatToSave]
      });

      // Process chat commands (if message starts with /)
      if (text.trim().startsWith('/')) {
        console.log('[Chat] Detected command in message:', text);
        processChatCommand(text, user, { ...data, wallet, avatarUrl: avatarUrl, profile_image: avatarUrl });
      }
    }
    
    function processChatCommand(text, user, data) {
      if (!text || typeof text !== 'string') {
        console.warn('[Command] Invalid text:', text);
        return;
      }
      
      const cmd = text.toLowerCase().trim();
      console.log('[Command] Processing:', { cmd, user, wallet: data.wallet || data.userAddress });
      
      // Support /start and /spin commands
      if (cmd === '/start' || cmd.startsWith('/start ') || cmd === '/spin' || cmd.startsWith('/spin ')) {
        const wallet = data.wallet || data.userAddress || "unknown";
        const avatarUrl = data.avatarUrl || data.profile_image || '';
        
        // Update user info cache when command is received
        if (wallet && wallet !== 'unknown') {
          const cacheKey = wallet;
          if (!userInfoCache[cacheKey]) {
            userInfoCache[cacheKey] = {};
          }
          if (avatarUrl) userInfoCache[cacheKey].avatarUrl = avatarUrl;
          userInfoCache[cacheKey].userAddress = wallet;
        }
        
        console.log('[Command] /start or /spin detected, adding to queue:', { user, wallet });
        addToQueue(user, wallet);
      } else if (cmd === '/points') {
        const wallet = data.wallet || data.userAddress || null;
        const avatarUrl = data.avatarUrl || data.profile_image || null;
        const cacheKey = wallet && wallet !== 'unknown' ? wallet : `user:${user.toLowerCase()}`;
        const userInfo = userInfoCache[cacheKey] || {};
        const finalAvatarUrl = avatarUrl || userInfo.avatarUrl || null;
        const isHolder = userInfo.isHolder || false;
        
        if (wallet && wallet !== 'unknown') {
          const points = slotState.userPoints[wallet] || 0;
          addLog(`ðŸ“Š ${user} has ${points} points (${points} to 1000)`, '#00d2ff', {
            username: user,
            userAddress: wallet,
            avatarUrl: finalAvatarUrl,
            isHolder: isHolder
          });
      } else {
          addLog(`âš ï¸ ${user} has no wallet address`, '#ff8800', {
            username: user,
            avatarUrl: finalAvatarUrl
          });
        }
            } else {
        console.log('[Command] Unknown command:', cmd);
      }
    }

    // --- SLOT MACHINE LOGIC ---
    const SLOT_CONFIG = {
      PRIZES: [
        { name: 'Nothing', prob: 0.40 },
        { name: 'Extra spin', prob: 0.15 },
        { name: '10 points', prob: 0.15 },
        { name: '25 points', prob: 0.10 },
        { name: 'Free Mint NFT', prob: 0.10 },
        { name: 'Jackpot', prob: 0.05 },
        { name: '50 points', prob: 0.05 }
      ],
      POINTS_REWARD_MEWVOLT: 1000,
      NFT_DAILY_LIMIT: 2
    };

    async function processQueue() {
      if (slotState.queue.length === 0) return;
      
      const player = slotState.queue.shift();
      
      // Play intro sound when player starts
      const introAudio = document.getElementById('slotSfxIntro');
      if (introAudio) {
        introAudio.currentTime = 0;
        introAudio.play().catch(e => console.warn('[Audio] Intro sound error:', e));
      }
      
      // Get player avatar from cache
      const playerCacheKey = player.wallet && player.wallet !== 'unknown' ? player.wallet : `user:${player.username.toLowerCase()}`;
      const playerInfo = userInfoCache[playerCacheKey] || {};
      const playerAvatarUrl = playerInfo.avatarUrl || null;
      
      // Show countdown phase (5 seconds)
      slotCurrent = { ...player, phase: 'countdown', avatarUrl: playerAvatarUrl, countdown: 5 };
      updateSlotMachineHud();
      
      // Countdown: 5, 4, 3, 2, 1
      for (let i = 5; i >= 1; i--) {
        await new Promise(r => setTimeout(r, 1000));
        if (slotCurrent && slotCurrent.phase === 'countdown') {
          slotCurrent.countdown = i;
          updateSlotMachineHud();
        }
      }
      
      // Switch to spinning phase
      slotCurrent.phase = 'spinning';
      updateSlotMachineHud();
      
      // 7. Increment daily spins counter
      const spinKey = (player.wallet && player.wallet !== 'unknown')
        ? player.wallet
        : `unknown:${String(player.username || 'user').toLowerCase()}`;
      if (player.kind !== 'bonus') {
        slotState.dailySpins[spinKey] = (slotState.dailySpins[spinKey] || 0) + 1;
        saveSlotState(); // Persist state
      }
      
      // Play spinning sound in loop
      const spinAudio = document.getElementById('slotSfxSpin');
      if (spinAudio) {
        spinAudio.loop = true;
        spinAudio.currentTime = 0;
        spinAudio.play().catch(e => console.warn('[Audio] Spin sound error:', e));
      }
      
      // Animate reels spinning (fast phase - 5 seconds)
      spinReels();
      
      // Fast spinning phase (5 seconds)
      await new Promise(r => setTimeout(r, 5000));
      
      // Slow down phase (start deceleration)
      slowDownReels();
      
      // Wait for slow down animation (2.5 seconds)
      await new Promise(r => setTimeout(r, 2500));
      
      // Select prize and stop reels (pass isHolder status for different probabilities)
      const prize = selectPrize(player.isHolder || false);
      
      // Stop spin sound
      if (spinAudio) {
        spinAudio.pause();
        spinAudio.currentTime = 0;
        spinAudio.loop = false;
      }
      
      stopReels(prize);
      
      slotCurrent.phase = 'result';
      slotCurrent.result = prize;
      
      // Process prize
      await processPrize(player.wallet, player.username, prize);
      
      updateSlotMachineHud();

            setTimeout(() => {
        slotCurrent = null;
        updateSlotMachineHud();
        processQueue();
      }, 3000);
    }

    function selectPrize(isHolder = true) {
      // Different probabilities for non-holders
      if (!isHolder) {
        const r = Math.random();
        if (r <= 0.50) {
          return 'Nothing'; // 50%
        } else if (r <= 0.85) {
          return '10 points'; // 35%
        } else {
          return '25 points'; // 15%
        }
      }
      
      // Original probabilities for holders
      const r = Math.random();
      let cumulative = 0;
      
      for (const prize of SLOT_CONFIG.PRIZES) {
        cumulative += prize.prob;
        if (r <= cumulative) {
          // Check NFT limit
          if (prize.name === 'Free Mint NFT') {
            const nftCount = (slotState.dailyNFTCount || 0);
            if (nftCount >= SLOT_CONFIG.NFT_DAILY_LIMIT) {
              // Fallback to points
              return Math.random() < 0.5 ? '25 points' : '10 points';
            }
          }
          return prize.name;
        }
      }
      return 'Nothing';
    }

    function spinReels() {
      const reels = document.querySelectorAll('#slotGrid .reel');
      reels.forEach((reel, reelIdx) => {
        reel.classList.add('spinning');
        
        // Animate each reel with different delays for visual effect
        setTimeout(() => {
          const symbols = reel.querySelectorAll('.symbol');
          symbols.forEach((sym, symIdx) => {
            sym.style.animation = `symbolSpin ${0.1 + reelIdx * 0.05}s linear infinite`;
          });
        }, reelIdx * 100);
      });
    }

    function slowDownReels() {
      const reels = document.querySelectorAll('#slotGrid .reel');
      reels.forEach((reel, reelIdx) => {
        reel.classList.remove('spinning');
        reel.classList.add('slowing');
        
        const symbols = reel.querySelectorAll('.symbol');
        symbols.forEach((sym, symIdx) => {
          // Gradually slow down animation (ease-out effect)
          const baseDuration = 0.15;
          const slowDuration = baseDuration + (reelIdx * 0.1) + (symIdx * 0.05);
          sym.style.animation = `symbolSpinSlow ${slowDuration}s ease-out infinite`;
        });
      });
    }

    function stopReels(prize) {
      const reels = document.querySelectorAll('#slotGrid .reel');
      
      // Stop each reel with staggered timing for better effect
      reels.forEach((reel, idx) => {
        setTimeout(() => {
          reel.classList.remove('spinning');
          reel.classList.remove('slowing');
          
          const symbols = reel.querySelectorAll('.symbol');
          symbols.forEach((sym, symIdx) => {
            sym.style.animation = 'none';
            sym.classList.remove('active');
            
            // Set final symbols based on prize (middle symbol shows the prize)
            // Middle symbol (symIdx === 1) shows the prize, others are random
            if (symIdx === 1) {
              sym.classList.add('active');
              
              // Determine symbol based on prize (all matching GAME_RULES.md)
              if (prize === 'Jackpot') {
                sym.textContent = '7';
                sym.className = 'symbol jackpot active';
              } else if (prize === '50 points') {
                sym.textContent = '50';
                sym.className = 'symbol points active';
              } else if (prize === '25 points') {
                sym.textContent = '25';
                sym.className = 'symbol points active';
              } else if (prize === '10 points') {
                sym.textContent = '10';
                sym.className = 'symbol points active';
              } else if (prize === 'Free Mint NFT') {
                sym.textContent = 'NFT';
                sym.className = 'symbol nft active';
              } else if (prize === 'Extra spin') {
                sym.textContent = 'SPIN';
                sym.className = 'symbol extra active';
      } else {
                // Nothing (40%)
                sym.textContent = 'â€”';
                sym.className = 'symbol empty active';
              }
        } else {
              // Fill other positions with random symbols from available prizes
              const allSymbols = [
                { text: '10', class: 'points' },
                { text: '25', class: 'points' },
                { text: '50', class: 'points' },
                { text: 'NFT', class: 'nft' },
                { text: 'SPIN', class: 'extra' },
                { text: '7', class: 'jackpot' },
                { text: 'â€”', class: 'empty' }
              ];
              const randomSym = allSymbols[Math.floor(Math.random() * allSymbols.length)];
              sym.textContent = randomSym.text;
              sym.className = `symbol ${randomSym.class}`;
            }
          });

          // Play stop sound on last reel
          if (idx === reels.length - 1) {
            const nextAudio = document.getElementById('slotSfxNext');
            if (nextAudio) {
              nextAudio.currentTime = 0;
              nextAudio.play().catch(e => console.warn('[Audio] Next sound error:', e));
            }
          }
        }, idx * 200);
      });
    }

    async function processPrize(wallet, username, prize) {
      // Get user info from slotCurrent or cache
      const player = slotCurrent || {};
      const isHolder = player.isHolder || false;
      
      // Get avatarUrl from cache
      const cacheKey = wallet && wallet !== 'unknown' ? wallet : `user:${username.toLowerCase()}`;
      const userInfo = userInfoCache[cacheKey] || {};
      const avatarUrl = userInfo.avatarUrl || null;
      const userAddress = wallet && wallet !== 'unknown' ? wallet : userInfo.userAddress || null;
      
      if (prize === 'Nothing') {
        addLog(`ðŸ˜” ${username} got nothing`, '#666', { username, userAddress, avatarUrl, isHolder });
        return;
      }
      
      if (prize === 'Extra spin') {
        slotState.queue.unshift({ username, wallet, kind: 'bonus' });
        addLog(`ðŸ”„ ${username} got extra spin!`, '#00d2ff', { username, userAddress, avatarUrl, isHolder });
        return;
      }
      
      if (prize.includes('points')) {
        const points = parseInt(prize.match(/\d+/)?.[0] || '0');
        if (points > 0) {
          if (!wallet || wallet === 'unknown') {
            addLog(`âš ï¸ ${username} has no wallet address (points not credited)`, '#ff8800', { username, avatarUrl });
        return;
      }

          slotState.userPoints[wallet] = (slotState.userPoints[wallet] || 0) + points;
          addLog(`ðŸŽ ${username} won ${points} points!`, '#00ff73', { username, userAddress, avatarUrl, isHolder });
          addWinner(username, `${points} points`, points, avatarUrl, userAddress, isHolder);
          saveSlotState();
          
          // Check for 1000 points milestone
          if (slotState.userPoints[wallet] >= 1000) {
            addLog(`ðŸ† ${username} reached 1000 points!`, '#ffcc00', { username, userAddress, avatarUrl, isHolder });
            // 5. Trigger payout for 1000 points
            payoutPoints(wallet, username);
            slotState.userPoints[wallet] = slotState.userPoints[wallet] - 1000;
            saveSlotState();
          }
        }
        return;
      }
      
      if (prize === 'Free Mint NFT') {
        slotState.dailyNFTCount = (slotState.dailyNFTCount || 0) + 1;
        addLog(`ðŸŽ¨ ${username} won Free Mint NFT!`, '#ff2975', { username, userAddress, avatarUrl, isHolder });
        addWinner(username, prize, null, avatarUrl, userAddress, isHolder);
        saveSlotState();
        return;
      }
      
      if (prize === 'Jackpot') {
        addLog(`ðŸŽ° ${username} WON THE JACKPOT! ${slotState.jackpot} MEWVOLT`, '#ffcc00', { username, userAddress, avatarUrl, isHolder });
        addWinner(username, `JACKPOT ${slotState.jackpot} MEWVOLT`, slotState.jackpot, avatarUrl, userAddress, isHolder);
        // 5. Trigger jackpot payout
        payoutJackpot(wallet, username);
        // Reset pot after win; rollover happens when not won
        slotState.jackpot = SLOT_CONFIG.POINTS_REWARD_MEWVOLT;
        updateJackpot();
        saveSlotState();
        return;
      }
      
      addWinner(username, prize, null, avatarUrl, userAddress, isHolder);
    }

    // --- UI UPDATES ---
    function updateChatHud() {
      const container = document.getElementById('chatMessages');
      if (!container) {
        console.warn('[Chat] Container chatMessages not found!');
        return;
      }
      console.log('[Chat] updateChatHud called, chatEntries.length:', chatEntries.length);
      // Remove duplicates based on username + message + timestamp (within 2 seconds)
      // Order: most recent first (chatEntries has newest at end, so take last 15 and reverse)
      const uniqueEntries = [];
      const seen = new Set();
      // Take last 15 entries (most recent) and iterate in reverse to show newest first
      // Only show messages that contain "/" (commands)
      for (const e of chatEntries.slice(-15).reverse()) {
        // Only include messages with "/" (commands)
        const messageText = (e.message || e.text || '').trim();
        if (!messageText.includes('/')) {
          continue; // Skip messages without "/"
        }
        
        const key = `${e.username}:${e.message}:${Math.floor(e.timestamp / 2000)}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniqueEntries.push(e);
        }
      }
      // uniqueEntries now has most recent first (newest at index 0)
      // Display them in order: newest first
      console.log('[Chat] Rendering', uniqueEntries.length, 'unique entries');
      container.innerHTML = uniqueEntries.map(e => {
        // Get holder status from entry or cache
        const cacheKey = e.userAddress && e.userAddress !== 'unknown' ? e.userAddress : `user:${e.username.toLowerCase()}`;
        const userInfo = userInfoCache[cacheKey] || {};
        const isHolder = e.isHolder || userInfo.isHolder || false;
        // Update entry with holder status if found in cache
        if (!e.isHolder && userInfo.isHolder) {
          e.isHolder = true;
        }
        console.log('[Chat] Rendering entry:', { username: e.username, avatarUrl: e.avatarUrl, isHolder: isHolder, entryIsHolder: e.isHolder, cacheIsHolder: userInfo.isHolder, userAddress: e.userAddress });
        // Render avatar: show image if available, with placeholder fallback on error
        const hasAvatarUrl = e.avatarUrl && e.avatarUrl.trim() && e.avatarUrl.trim() !== '';
        const avatarImg = hasAvatarUrl ? `<img src="${e.avatarUrl}" alt="${e.username}" class="avatar" crossorigin="anonymous" referrerpolicy="no-referrer" loading="lazy" onerror="this.style.display='none'; const next=this.nextElementSibling; if(next && next.classList && next.classList.contains('avatar-placeholder')) { next.style.display='block'; }">` : '';
        const avatarPlaceholder = `<div class="avatar avatar-placeholder" style="background: rgba(255,255,255,0.1); width:24px; height:24px; border-radius:50%; flex-shrink:0; ${hasAvatarUrl ? 'display:none;' : ''}"></div>`;
        const holderTag = isHolder ? '<span style="color:var(--gold);font-size:10px;margin-left:4px;font-weight:700;">HOLDER</span>' : '';
        return `
        <div class="item-row">
          ${avatarImg}${avatarPlaceholder}
          <div class="content">
            <span class="ts">${new Date(e.timestamp).toLocaleTimeString()}</span>
            <span class="user">${e.username}${holderTag}:</span>
            <span class="msg">${e.message}</span>
          </div>
        </div>
      `;
      }).join('');
    }

    function addLog(text, color, meta = {}) {
      // Check for duplicates (same text within last 5 seconds)
      const now = Date.now();
      const isDuplicate = logEntries.some(e => 
        e.text === text && Math.abs(e.ts - now) < 5000
      );
      if (isDuplicate) {
        return; // Skip duplicate
      }
      
      // Get user info from cache if not provided in meta
      let avatarUrl = meta.avatarUrl || null;
      let isHolder = meta.isHolder !== undefined ? meta.isHolder : null;
      let userAddress = meta.userAddress || null;
      
      if (meta.username || meta.userAddress) {
        const cacheKey = meta.userAddress && meta.userAddress !== 'unknown' 
          ? meta.userAddress 
          : meta.username ? `user:${meta.username.toLowerCase()}` : null;
        if (cacheKey && userInfoCache[cacheKey]) {
          if (!avatarUrl) avatarUrl = userInfoCache[cacheKey].avatarUrl || null;
          if (isHolder === null) isHolder = userInfoCache[cacheKey].isHolder || false;
          if (!userAddress) userAddress = userInfoCache[cacheKey].userAddress || null;
        }
      }
      
      // Save to drive_db
      const levelFromColor = (c) => {
        if (!c) return 'info';
        const v = String(c).toLowerCase();
        if (v === '#00ff73') return 'success';
        if (v === '#ff8800') return 'warn';
        if (v === '#ff4444') return 'error';
        if (v === '#ffcc00') return 'special';
        return 'info';
      };
      const logEntry = {
        ts: now,
        username: meta.username || null,
        text: text,
        action: meta.action || null,
        userAddress: userAddress,
        avatarUrl: avatarUrl,
        isHolder: isHolder === true,
        level: meta.level || levelFromColor(color)
      };
      logEntries.unshift(logEntry); // Add to start
      if (logEntries.length > 20) logEntries.pop(); // Remove from end
      
      // Update UI from array (prevents duplicates)
      updateLogsHud();
      
      saveToDriveDb({ logs: [logEntry] });
    }

    function updateLogsHud() {
      const container = document.getElementById('logsList');
      if (!container) return;
      container.innerHTML = logEntries.map(e => {
        let text = e.text || e.action || JSON.stringify(e);
        const level = e.level || 'info';
        const color = level === 'success' ? '#00ff73'
          : level === 'warn' ? '#ff8800'
          : level === 'error' ? '#ff4444'
          : level === 'special' ? '#ffcc00'
          : '#ccc';
        // Get holder status from entry or cache
        const cacheKey = e.userAddress && e.userAddress !== 'unknown' ? e.userAddress : (e.username ? `user:${e.username.toLowerCase()}` : null);
        const userInfo = cacheKey ? (userInfoCache[cacheKey] || {}) : {};
        const isHolder = e.isHolder || userInfo.isHolder || false;
        // Update entry with holder status if found in cache
        if (!e.isHolder && userInfo.isHolder) {
          e.isHolder = true;
        }
        console.log('[Logs] Rendering entry:', { username: e.username, avatarUrl: e.avatarUrl, isHolder: isHolder, entryIsHolder: e.isHolder, cacheIsHolder: userInfo.isHolder, userAddress: e.userAddress });
        const avatarImg = e.avatarUrl && e.avatarUrl.trim() ? `<img src="${e.avatarUrl}" alt="${e.username || ''}" class="avatar" crossorigin="anonymous" referrerpolicy="no-referrer" onerror="this.onerror=null; this.src=''; this.style.display='none'; this.nextElementSibling?.style.display='block';">` : '';
        const avatarPlaceholder = `<div class="avatar" style="background: rgba(255,255,255,0.1); ${e.avatarUrl && e.avatarUrl.trim() ? 'display:none;' : ''}"></div>`;
        const holderTag = isHolder ? '<span style="color:var(--gold);font-size:10px;margin-left:4px;font-weight:700;">HOLDER</span>' : '';
        const usernamePart = e.username ? `<span class="user">${e.username}${holderTag}</span> ` : '';
        
        // Remove username from text if it's already shown separately
        if (e.username && usernamePart) {
          // Remove username patterns: "ðŸ“Š username has...", "username joined...", "username got...", etc.
          // Match username at start or after emoji/whitespace
          const escapedUsername = e.username.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const usernameRegex = new RegExp(`(^|\\s)${escapedUsername}\\s+`, 'i');
          text = text.replace(usernameRegex, '$1');
          // Also handle cases where username appears with emoji prefix
          const emojiUsernameRegex = new RegExp(`[ðŸ“ŠðŸŽŸï¸âš ï¸ðŸ”„ðŸŽðŸ†ðŸŽ¨ðŸŽ°ðŸ˜”âœ…ðŸ”—]\\s*${escapedUsername}\\s+`, 'i');
          text = text.replace(emojiUsernameRegex, '');
        }
        
        return `<div class="item-row" style="color:${color}">
          ${avatarImg}${avatarPlaceholder}
          <div class="content">
            <span class="ts">${new Date(e.ts || Date.now()).toLocaleTimeString()}</span> ${usernamePart}${text}
          </div>
        </div>`;
      }).join('');
    }

    function addWinner(user, prize, amount = null, avatarUrl = null, userAddress = null, isHolder = null) {
      // Check for duplicates (same user + prize within last 5 seconds)
      const now = Date.now();
      const isDuplicate = winnersEntries.some(e => 
        e.username === user && e.prize === prize && Math.abs(e.ts - now) < 5000
      );
      if (isDuplicate) {
        return; // Skip duplicate
      }
      
      // Get user info from cache if not provided
      let finalAvatarUrl = avatarUrl || null;
      let finalIsHolder = isHolder !== null ? isHolder : false;
      let finalUserAddress = userAddress || null;
      
      if (user) {
        const cacheKey = finalUserAddress && finalUserAddress !== 'unknown' 
          ? finalUserAddress 
          : `user:${user.toLowerCase()}`;
        if (userInfoCache[cacheKey]) {
          if (!finalAvatarUrl) finalAvatarUrl = userInfoCache[cacheKey].avatarUrl || null;
          if (finalIsHolder === null || finalIsHolder === false) finalIsHolder = userInfoCache[cacheKey].isHolder || false;
          if (!finalUserAddress) finalUserAddress = userInfoCache[cacheKey].userAddress || null;
        }
      }
      
      // Save to drive_db
      const winnerEntry = {
        ts: now,
        username: user,
        prize: prize,
        amount: amount,
        avatarUrl: finalAvatarUrl,
        userAddress: finalUserAddress,
        isHolder: finalIsHolder === true
      };
      winnersEntries.unshift(winnerEntry); // Add to start
      if (winnersEntries.length > 10) winnersEntries.pop(); // Remove from end
      
      // Update UI from array (prevents duplicates)
      updateWinnersHud();
      
      saveToDriveDb({ winners: [winnerEntry] });
    }

    function updateWinnersHud() {
      const container = document.getElementById('winnersList');
      if (!container) return;
      container.innerHTML = winnersEntries.map(e => {
        const prize = e.prize || e.action || 'PRIZE';
        // Get holder status from entry or cache
        const cacheKey = e.userAddress && e.userAddress !== 'unknown' ? e.userAddress : (e.username ? `user:${e.username.toLowerCase()}` : null);
        const userInfo = cacheKey ? (userInfoCache[cacheKey] || {}) : {};
        const isHolder = e.isHolder || userInfo.isHolder || false;
        // Update entry with holder status if found in cache
        if (!e.isHolder && userInfo.isHolder) {
          e.isHolder = true;
        }
        console.log('[Winners] Rendering entry:', { username: e.username, avatarUrl: e.avatarUrl, isHolder: isHolder, entryIsHolder: e.isHolder, cacheIsHolder: userInfo.isHolder, userAddress: e.userAddress });
        const avatarImg = e.avatarUrl && e.avatarUrl.trim() ? `<img src="${e.avatarUrl}" alt="${e.username || ''}" class="avatar" crossorigin="anonymous" referrerpolicy="no-referrer" onerror="this.onerror=null; this.src=''; this.style.display='none'; this.nextElementSibling?.style.display='block';">` : '';
        const avatarPlaceholder = `<div class="avatar" style="background: rgba(255,255,255,0.1); ${e.avatarUrl && e.avatarUrl.trim() ? 'display:none;' : ''}"></div>`;
        const holderTag = isHolder ? '<span style="color:var(--gold);font-size:10px;margin-left:4px;font-weight:700;">HOLDER</span>' : '';
        const timestamp = e.ts ? new Date(e.ts).toLocaleTimeString() : '';
        return `<div class="item-row">
          ${avatarImg}${avatarPlaceholder}
          <div class="content">
            <span class="ts">${timestamp}</span>
            <span class="user">${e.username || 'Unknown'}${holderTag}</span> won 
            <span style="color:var(--gold)">${prize}</span>
          </div>
        </div>`;
      }).join('');
    }

    function updateSlotMachineHud() {
      const queueEl = document.getElementById('slotQueue');
      const queueLength = slotState.queue.length;
      
      // Show queue count and list of players ahead
      if (queueLength > 0) {
        const queueList = slotState.queue.slice(0, 5).map((q, idx) => {
          const cacheKey = q.wallet && q.wallet !== 'unknown' ? q.wallet : `user:${q.username.toLowerCase()}`;
          const userInfo = userInfoCache[cacheKey] || {};
          const avatarUrl = userInfo.avatarUrl || '';
          const isHolder = q.isHolder || userInfo.isHolder || false;
          const holderTag = isHolder ? ' <span style="color:var(--gold);font-size:8px;">H</span>' : '';
          const avatarImg = avatarUrl && avatarUrl.trim() ? `<img src="${avatarUrl}" alt="${q.username}" style="width:16px;height:16px;border-radius:50%;margin-right:4px;object-fit:cover;" onerror="this.style.display='none';">` : '';
          return `${idx + 1}. ${avatarImg}${q.username}${holderTag}`;
        }).join(' ');
        queueEl.innerHTML = `Q: ${queueLength}${queueLength > 5 ? '+' : ''} ${queueLength > 0 ? 'â€” ' : ''}${queueList}`;
      } else {
        queueEl.textContent = `Q: 0`;
      }
      
      const status = document.getElementById('slotWaiting');
      const statusBox = document.getElementById('statusBox');
      
      if (slotCurrent) {
        // Get player info from cache
        const player = slotCurrent;
        const cacheKey = player.wallet && player.wallet !== 'unknown' ? player.wallet : `user:${player.username.toLowerCase()}`;
        const userInfo = userInfoCache[cacheKey] || {};
        const avatarUrl = userInfo.avatarUrl || null;
        const isHolder = player.isHolder || userInfo.isHolder || false;
        
        // Update status box with player info and phase
        const holderTag = isHolder ? '<span class="holder-badge">HOLDER</span>' : '';
        const avatarImg = avatarUrl ? `<img src="${avatarUrl}" alt="${player.username}" class="player-avatar" onerror="this.style.display='none'">` : '<div class="player-avatar" style="background: rgba(255,255,255,0.1); border: 2px solid var(--neon-blue);"></div>';
        
        let phaseText, phaseColor;
        
        if (player.phase === 'countdown') {
          phaseText = `Waiting for ${player.username}`;
          phaseColor = 'var(--neon-blue)';
          statusBox.innerHTML = `
            <div class="player-info">
              ${avatarImg}
              <div>
                <span class="player-name">${player.username}${holderTag}</span>
              </div>
            </div>
            <div style="color: ${phaseColor}; font-size: 16px; font-weight: 700; margin-top: 5px;">${phaseText}</div>
            <div style="color: var(--gold); font-size: 48px; font-weight: 900; margin-top: 10px; line-height: 1;">${player.countdown || 5}</div>
          `;
        } else if (player.phase === 'spinning') {
          phaseText = 'ROLLING...';
          phaseColor = 'var(--gold)';
          statusBox.innerHTML = `
            <div class="player-info">
              ${avatarImg}
              <div>
                <span class="player-name">${player.username}${holderTag}</span>
              </div>
            </div>
            <div style="color: ${phaseColor}; font-size: 16px; font-weight: 700; margin-top: 5px;">${phaseText}</div>
          `;
        } else if (player.phase === 'result') {
          phaseText = `WON: ${player.result}`;
          phaseColor = 'var(--neon-green)';
          statusBox.innerHTML = `
            <div class="player-info">
              ${avatarImg}
              <div>
                <span class="player-name">${player.username}${holderTag}</span>
              </div>
            </div>
            <div style="color: ${phaseColor}; font-size: 16px; font-weight: 700; margin-top: 5px;">${phaseText}</div>
          `;
        } else {
          phaseText = 'PLAYING';
          phaseColor = 'var(--neon-blue)';
          statusBox.innerHTML = `
            <div class="player-info">
              ${avatarImg}
              <div>
                <span class="player-name">${player.username}${holderTag}</span>
              </div>
            </div>
            <div style="color: ${phaseColor}; font-size: 16px; font-weight: 700; margin-top: 5px;">${phaseText}</div>
          `;
        }
        
        status.textContent = player.phase === 'spinning' ? 'ROLLING...' : player.phase === 'countdown' ? `Waiting for ${player.username}` : `WINNER: ${player.result}`;
        status.style.color = player.phase === 'spinning' ? 'var(--gold)' : player.phase === 'result' ? 'var(--neon-green)' : 'var(--neon-blue)';
      } else {
        // No current player - show default
        statusBox.innerHTML = `
          <p style="font-size: 10px; color: #555; margin-bottom: 5px; font-weight: 900;">SYSTEM READY</p>
          <div>Type <span>/start</span> in chat to join</div>
        `;
        status.textContent = 'WAITING FOR BETS';
        status.style.color = 'rgba(255,255,255,0.05)';
      }
    }

    function updateSlotLiveTimer() {
      const el = document.getElementById('slotLive');
      const now = new Date();
      el.textContent = `LIVE ${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
    }

    function updateDateTime() {
      document.getElementById('slotDateTime').textContent = new Date().toLocaleString();
    }

    // --- DRIVE DB PERSISTENCE ---
    async function loadPersistentData() {
      try {
        const res = await fetch('/drive/read');
        if (!res.ok) {
          console.warn(`[Drive DB] Read endpoint returned ${res.status} - server may need restart`);
          return;
        }
        const text = await res.text();
        let result;
        try {
          result = JSON.parse(text);
        } catch (e) {
          console.warn('[Drive DB] Response is not JSON:', text.substring(0, 100));
          return;
        }
        if (result.ok && result.data) {
          // Load chats
          if (Array.isArray(result.data.chats)) {
            chatEntries = result.data.chats
              .map(c => {
                const wallet = c.userAddress || null;
                const cacheKey = wallet && wallet !== 'unknown' ? wallet : `user:${(c.username || 'unknown').toLowerCase()}`;
                const avatarUrl = c.avatarUrl || '';
                
                // Update cache from loaded data
                if (cacheKey && !userInfoCache[cacheKey]) {
                  userInfoCache[cacheKey] = {};
                }
                if (avatarUrl && cacheKey) {
                  userInfoCache[cacheKey].avatarUrl = avatarUrl;
                }
                if (wallet && cacheKey) {
                  userInfoCache[cacheKey].userAddress = wallet;
                }
                
                return {
                  username: c.username || 'Unknown',
                  message: c.text || '',
                  timestamp: c.ts || Date.now(),
                  avatarUrl: avatarUrl,
                  userAddress: wallet,
                  isHolder: false // Will be updated async below
                };
              })
              .filter(c => c.message)
              .slice(-50);
            
            // Check holder status for loaded chat entries
            chatEntries.forEach(entry => {
              if (entry.userAddress && entry.userAddress !== 'unknown') {
                checkIsHolder(entry.userAddress).then(isHolder => {
                  entry.isHolder = isHolder;
                  const cacheKey = entry.userAddress;
                  if (userInfoCache[cacheKey]) {
                    userInfoCache[cacheKey].isHolder = isHolder;
                  }
                  updateChatHud();
                }).catch(() => {
                  entry.isHolder = false;
                });
              }
            });
            
            updateChatHud();
          }
          
          // Load logs
          // Drive DB stores logs in chronological order, but we add with unshift (newest first)
          // So when loading, we need to reverse to match the unshift order (newest first)
          if (Array.isArray(result.data.logs)) {
            logEntries = result.data.logs.slice(-20).reverse().map(log => {
              // Ensure all fields are present
              return {
                ...log,
                avatarUrl: log.avatarUrl || null,
                userAddress: log.userAddress || null,
                isHolder: log.isHolder === true,
                username: log.username || null
              };
            });
            
            // Update cache from loaded logs
            logEntries.forEach(log => {
              if (log.userAddress || log.username) {
                const cacheKey = log.userAddress && log.userAddress !== 'unknown' 
                  ? log.userAddress 
                  : log.username ? `user:${log.username.toLowerCase()}` : null;
                if (cacheKey) {
                  if (!userInfoCache[cacheKey]) {
                    userInfoCache[cacheKey] = {};
                  }
                  if (log.avatarUrl) userInfoCache[cacheKey].avatarUrl = log.avatarUrl;
                  if (log.userAddress) userInfoCache[cacheKey].userAddress = log.userAddress;
                  if (log.isHolder) userInfoCache[cacheKey].isHolder = true;
                }
              }
            });
            
            updateLogsHud();
          }
          
          // Load winners
          if (Array.isArray(result.data.winners)) {
            winnersEntries = result.data.winners.slice(-10).reverse().map(winner => {
              // Ensure all fields are present
              return {
                ...winner,
                avatarUrl: winner.avatarUrl || null,
                userAddress: winner.userAddress || null,
                isHolder: winner.isHolder === true
              };
            });
            
            // Update cache from loaded winners
            winnersEntries.forEach(winner => {
              if (winner.userAddress || winner.username) {
                const cacheKey = winner.userAddress && winner.userAddress !== 'unknown' 
                  ? winner.userAddress 
                  : winner.username ? `user:${winner.username.toLowerCase()}` : null;
                if (cacheKey) {
                  if (!userInfoCache[cacheKey]) {
                    userInfoCache[cacheKey] = {};
                  }
                  if (winner.avatarUrl) userInfoCache[cacheKey].avatarUrl = winner.avatarUrl;
                  if (winner.userAddress) userInfoCache[cacheKey].userAddress = winner.userAddress;
                  if (winner.isHolder) userInfoCache[cacheKey].isHolder = true;
                }
              }
            });
            
            updateWinnersHud();
          }
          
          // 6. Load slotState from drive_db
          if (result.data.slotState) {
            const loadedSlotState = result.data.slotState;
            console.log('[Drive DB] Loading slotState:', loadedSlotState);
            
            Object.assign(slotState, {
              ...slotState,
              ...loadedSlotState,
              queue: [], // Don't restore queue on load
              lastResetDate: loadedSlotState.lastResetDate || new Date().toDateString(),
              dailySpins: loadedSlotState.dailySpins || {},
              userPoints: loadedSlotState.userPoints || {},
              jackpot: Number(loadedSlotState.jackpot) || 1000,
              dailyNFTCount: Number(loadedSlotState.dailyNFTCount) || 0,
              dailyPurchasesSOL: Number(loadedSlotState.dailyPurchasesSOL) || 0,
              yesterdayPurchasesSOL: Number(loadedSlotState.yesterdayPurchasesSOL) || 0
            });
            
            console.log('[Drive DB] SlotState loaded:', slotState);
            
            // Check if daily reset needed
            checkDailyReset();
          } else {
            console.warn('[Drive DB] No slotState found in drive_db.json, using defaults');
          }
          
          console.log('[Drive DB] Loaded:', { 
            chats: chatEntries.length, 
            logs: logEntries.length, 
            winners: winnersEntries.length,
            slotState: !!result.data.slotState,
            jackpot: slotState.jackpot,
            dailySpinsCount: Object.keys(slotState.dailySpins || {}).length,
            userPointsCount: Object.keys(slotState.userPoints || {}).length
          });
        }
      } catch (err) {
        console.error('[Drive DB] Load error:', err);
      }
    }

    // 6. Persist slotState to drive_db
    async function saveSlotState() {
      try {
        const stateToSave = {
          ...slotState,
          queue: [] // Don't persist queue
        };
        console.log('[SlotState] Saving to drive_db.json:', stateToSave);
        
        // Save via append (slotState is merged server-side)
        const res = await fetch('/drive/append', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ slotState: stateToSave })
        });
        
        const result = await res.json();
        if (result.ok) {
          console.log('[SlotState] Saved successfully to MeVoltOBS/drive_db.json');
        } else {
          console.error('[SlotState] Save failed:', result.error);
        }
      } catch (err) {
        console.error('[SlotState] Save error:', err);
      }
    }

    async function saveToDriveDb(data) {
      try {
        const res = await fetch('/drive/append', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        const result = await res.json();
        if (result.ok) {
          console.log('[Drive DB] Saved successfully to MeVoltOBS/drive_db.json:', Object.keys(data));
        } else {
          console.error('[Drive DB] Save failed:', result.error);
        }
      } catch (err) {
        console.error('[Drive DB] Save error:', err);
      }
    }

    // 2. Daily reset check and execution
    async function checkDailyReset() {
      const today = new Date().toDateString();
      if (slotState.lastResetDate !== today) {
        await resetDailySlotData();
      }
    }

    async function resetDailySlotData() {
      const today = new Date().toDateString();
      
      // 3. Calculate jackpot from yesterday's purchases
      slotState.yesterdayPurchasesSOL = slotState.dailyPurchasesSOL || 0;
      await applyDailyJackpotUpdate();
      
      // Reset daily counters
      slotState.dailySpins = {};
      slotState.dailyNFTCount = 0;
      slotState.dailyPurchasesSOL = 0;
      slotState.lastResetDate = today;
      
      saveSlotState();
      addLog(`[Daily Reset] Reset completed for ${today}`, '#ccc', { level: 'info' });
    }

    // 3. Update jackpot based on yesterday's purchases
    async function updateJackpot() {
      slotState.jackpot = Number(slotState.jackpot) || 0;
      // Minimum jackpot: 1000 MEWVOLT
      if (!slotState.jackpot || slotState.jackpot < 1000) {
        slotState.jackpot = SLOT_CONFIG.POINTS_REWARD_MEWVOLT;
      }
      
      // Update UI
      const jackpotEl = document.getElementById('slotJackpot');
      if (jackpotEl) {
        jackpotEl.textContent = `JACKPOT: ${slotState.jackpot.toFixed(0)} MEWVOLT`;
      }
      saveSlotState();
    }

    async function applyDailyJackpotUpdate() {
      const mewvoltPriceInSOL = await fetchMewvoltPriceInSOL();
      const jackpotInSOL = (slotState.yesterdayPurchasesSOL || 0) / 10;
      let contribution = 0;
      if (jackpotInSOL > 0 && mewvoltPriceInSOL > 0) {
        contribution = jackpotInSOL / mewvoltPriceInSOL;
      }

      if (!contribution || contribution <= 0) {
        contribution = 1000;
      }

      const current = Number(slotState.jackpot) || 0;
      slotState.jackpot = current + contribution;
      if (slotState.jackpot < 1000) slotState.jackpot = 1000;

      await updateJackpot();
    }

    async function fetchMewvoltPriceInSOL() {
      try {
        const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${CONFIG.contract}`);
        const data = await res.json();
        if (data.pairs && data.pairs[0]) {
          return parseFloat(data.pairs[0].priceNative) || 0;
        }
      } catch (e) {}
      return 0;
    }

    // 5. Payout functions
    async function payoutPoints(wallet, username) {
      if (!wallet || wallet === 'unknown') {
        addLog(`âš ï¸ Payout ignored: ${username} has no wallet address`, '#ff8800');
        return;
      }
      
      try {
        const tokenRes = await fetch('/payout-token');
        const tokenData = await tokenRes.json();
        const payoutToken = tokenData.token;
        
        if (!payoutToken) {
          addLog(`âš ï¸ Payout failed: PAYOUT_TOKEN not configured`, '#ff4444');
          return;
        }
        
        const payoutRes = await fetch('/payout', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'x-payout-token': payoutToken
          },
          body: JSON.stringify({
            kind: 'spl',
            toWallet: wallet,
            mint: CONFIG.contract,
            amountTokens: SLOT_CONFIG.POINTS_REWARD_MEWVOLT
          })
        });
        
        const result = await payoutRes.json();
        if (result.ok && result.sig) {
          addLog(`âœ… Payout sent: ${username} received ${SLOT_CONFIG.POINTS_REWARD_MEWVOLT} MEWVOLT`, '#00ff73');
          addLog(`ðŸ”— TX: https://solscan.io/tx/${result.sig}`, '#00d2ff');
        } else {
          addLog(`âŒ Payout failed: ${result.error || 'Unknown error'}`, '#ff4444');
        }
      } catch (err) {
        addLog(`âŒ Payout error: ${err.message}`, '#ff4444');
      }
    }

    async function payoutJackpot(wallet, username) {
      if (!wallet || wallet === 'unknown') {
        addLog(`âš ï¸ Payout ignored: ${username} has no wallet address`, '#ff8800');
        return;
      }
      
      try {
        const tokenRes = await fetch('/payout-token');
        const tokenData = await tokenRes.json();
        const payoutToken = tokenData.token;
        
        if (!payoutToken) {
          addLog(`âš ï¸ Jackpot payout failed: PAYOUT_TOKEN not configured`, '#ff4444');
          return;
        }
        
        const jackpotAmount = slotState.jackpot || SLOT_CONFIG.POINTS_REWARD_MEWVOLT;
        
        const payoutRes = await fetch('/payout', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'x-payout-token': payoutToken
          },
          body: JSON.stringify({
            kind: 'spl',
            toWallet: wallet,
            mint: CONFIG.contract,
            amountTokens: jackpotAmount
          })
        });
        
        const result = await payoutRes.json();
        if (result.ok && result.sig) {
          addLog(`âœ… Payout sent: ${username} received ${jackpotAmount} MEWVOLT`, '#00ff73');
          addLog(`ðŸ”— TX: https://solscan.io/tx/${result.sig}`, '#00d2ff');
        } else {
          addLog(`âŒ Jackpot payout failed: ${result.error || 'Unknown error'}`, '#ff4444');
        }
      } catch (err) {
        addLog(`âŒ Jackpot payout error: ${err.message}`, '#ff4444');
      }
    }

    // 1. Holder check and daily limits
    async function checkIsHolder(wallet) {
      if (!wallet || wallet === 'unknown') return false;
      try {
        const res = await fetch(`/holder-check?wallet=${encodeURIComponent(wallet)}`);
        const data = await res.json();
        const isHolder = data.ok && data.isHolder === true;
        console.log('[HolderCheck] Result:', { wallet, ok: data.ok, isHolder: data.isHolder, result: isHolder, data });
        return isHolder;
      } catch (e) {
        console.warn('[HolderCheck] Error:', { wallet, error: e.message });
        return false;
      }
    }

    function getDailySpinLimit(isHolder) {
      return isHolder ? 3 : 1;
    }

    async function addToQueue(username, wallet) {
      console.log('[Queue] addToQueue called:', { username, wallet });
      
      // Check if already in queue
      const alreadyInQueue = slotState.queue.some(q => q.username === username || (wallet && wallet !== 'unknown' && q.wallet === wallet));
      if (alreadyInQueue) {
        console.log('[Queue] Already in queue:', username);
        return;
      }
      
      // Check daily reset
      await checkDailyReset();
      
      // 1. Check holder status (only if wallet is valid)
      let isHolder = false;
      const cacheKey = wallet && wallet !== 'unknown' ? wallet : `user:${username.toLowerCase()}`;
      
      // Check cache first to get holder status if already validated
      if (wallet && wallet !== 'unknown' && userInfoCache[cacheKey] && userInfoCache[cacheKey].isHolder !== undefined) {
        isHolder = userInfoCache[cacheKey].isHolder;
        console.log('[Queue] Using cached holder status:', { wallet, isHolder });
      }
      
      // If not in cache or wallet is valid, check holder status
      if (wallet && wallet !== 'unknown') {
        try {
          const checkedHolder = await checkIsHolder(wallet);
          console.log('[Queue] Holder check result:', { wallet, isHolder: checkedHolder, wasCached: isHolder === checkedHolder });
          
          // Use the checked result (may update if different from cache)
          isHolder = checkedHolder;
          
          // Update cache with holder status
          if (!userInfoCache[cacheKey]) {
            userInfoCache[cacheKey] = {};
          }
          userInfoCache[cacheKey].isHolder = isHolder;
          userInfoCache[cacheKey].userAddress = wallet;
        } catch (e) {
          console.warn('[Queue] Holder check failed:', e);
          // If check failed, keep using cached value (if available) or default to false
          if (userInfoCache[cacheKey] && userInfoCache[cacheKey].isHolder !== undefined) {
            isHolder = userInfoCache[cacheKey].isHolder;
          }
        }
      }
      
      // Calculate limit based on validated isHolder (not cache, which may be outdated)
      const limit = getDailySpinLimit(isHolder);
      const spinKey = (wallet && wallet !== 'unknown')
        ? wallet
        : `unknown:${String(username || 'user').toLowerCase()}`;
      const currentSpins = slotState.dailySpins[spinKey] || 0;
      
      // Ensure cache is updated with the latest isHolder value before calculating limit
      if (wallet && wallet !== 'unknown' && userInfoCache[cacheKey]) {
        userInfoCache[cacheKey].isHolder = isHolder;
      }
      
      console.log('[Queue] Spin limits:', { spinKey, currentSpins, limit, isHolder, cacheIsHolder: userInfoCache[cacheKey]?.isHolder, cacheKey });
      
      // Ensure cache is initialized and updated with latest values
      if (!userInfoCache[cacheKey]) {
        userInfoCache[cacheKey] = {};
      }
      userInfoCache[cacheKey].isHolder = isHolder; // Always update with validated value
      if (wallet && wallet !== 'unknown') {
        userInfoCache[cacheKey].userAddress = wallet;
      }
      
      // Try to get avatarUrl from cache, or from chat entries
      let avatarUrl = userInfoCache[cacheKey]?.avatarUrl || null;
      if (!avatarUrl && wallet && wallet !== 'unknown') {
        // Try to find avatar from recent chat entries
        const chatEntry = chatEntries.find(c => c.userAddress === wallet || c.username === username);
        if (chatEntry && chatEntry.avatarUrl) {
          avatarUrl = chatEntry.avatarUrl;
          userInfoCache[cacheKey].avatarUrl = avatarUrl; // Update cache
        }
      }
      
      // Check if user has reached daily limit
      if (currentSpins >= limit) {
        // Use the validated isHolder (not cache, which may be outdated)
        console.log('[Queue] Daily limit reached - Logging:', { username, wallet, isHolder, limit, avatarUrl, cacheKey });
        addLog(`âš ï¸ ${username} reached daily limit (${limit} spins/day)`, '#ff8800', { 
          username, 
          userAddress: wallet !== 'unknown' ? wallet : null,
          avatarUrl: avatarUrl,
          isHolder: isHolder // Use validated isHolder, not cache
        });
        return;
      }
      
      slotState.queue.push({ username, wallet: wallet || 'unknown', isHolder, kind: 'normal' });
      const userInfo = userInfoCache[cacheKey] || {};
      // Use the validated isHolder value, not the cache (cache may be outdated)
      const finalIsHolder = isHolder || userInfo.isHolder || false;
      addLog(`ðŸŽŸï¸ ${username} joined the queue (${currentSpins + 1}/${limit} spins)`, '#00d2ff', {
        username,
        userAddress: wallet !== 'unknown' ? wallet : null,
        avatarUrl: userInfo.avatarUrl || null,
        isHolder: finalIsHolder
      });
      updateSlotMachineHud();
      
      console.log('[Queue] Added to queue:', { username, wallet, queueLength: slotState.queue.length });
      
      if (!slotCurrent) {
        console.log('[Queue] Starting queue processing');
        processQueue();
      } else {
        console.log('[Queue] Queue processing already in progress');
      }
    }

    // --- THREE.JS WORLD MAP ---
    let threeScene, threeCamera, threeRenderer, threeAnimId;
    
    function initThreeWorldMap() {
      if (typeof THREE === 'undefined') {
        console.error('[Three.js] Library not loaded!');
        return;
      }
      
      const canvas = document.getElementById('gardenCanvas');
      if (!canvas) {
        console.error('[Three.js] Canvas not found!');
        return;
      }
      
      // Scene
      threeScene = new THREE.Scene();
      threeScene.background = new THREE.Color(0x07080a);
      
      // Camera
      const width = window.innerWidth;
      const height = window.innerHeight;
      threeCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
      threeCamera.position.set(0, 5, 10);
      threeCamera.lookAt(0, 0, 0);
      
      // Renderer
      threeRenderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        antialias: true,
        alpha: true 
      });
      threeRenderer.setSize(width, height);
      threeRenderer.setPixelRatio(window.devicePixelRatio);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      threeScene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      threeScene.add(directionalLight);
      
      // Ground plane (simple)
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a,
        roughness: 0.8
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      threeScene.add(ground);
      
      // Simple geometric shapes for visual interest
      const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
      const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff73 });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(0, 1, 0);
      threeScene.add(box);
      
      // Animation loop
      function animate() {
        threeAnimId = requestAnimationFrame(animate);
        
        // Rotate box slowly
        if (box) {
          box.rotation.y += 0.01;
        }
        
        threeRenderer.render(threeScene, threeCamera);
      }
      
      // Handle window resize
      window.addEventListener('resize', () => {
        if (!threeCamera || !threeRenderer) return;
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      animate();
      console.log('[Three.js] World Map initialized successfully');
    }
    
    function initThreeGarden() { 
      console.log("Initializing 2D Garden..."); 
      // Placeholder for mode-0 garden
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>